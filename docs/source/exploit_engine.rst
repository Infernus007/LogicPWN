.. _exploit-engine:

Automated Exploit Engine & Chain Orchestration
==============================================

LogicPwn features a powerful exploit automation engine for chaining multi-step attacks, leveraging authenticated sessions, advanced payloads, and flexible validation. You can define exploit chains in YAML or JSON, and run them synchronously or asynchronously.

Overview
--------

The exploit engine enables:

- Multi-step exploit chains with session state
- Config-driven (YAML/JSON) chain definitions
- Advanced payload injection (static, random, fuzz, template, context-aware)
- Flexible validation (status code, Python expressions, JSONPath, session state)
- Async/parallel execution for high throughput
- Caching, performance monitoring, and logging
- Extensibility for new payloads, validations, and extractors

.. seealso::
   For access/IDOR detection, see :doc:`access_detection`.

Key Functions
-------------

.. autofunction:: logicpwn.core.exploit_engine.exploit_engine.run_exploit_chain
.. autofunction:: logicpwn.core.exploit_engine.exploit_engine.async_run_exploit_chain
   :no-index:
.. autofunction:: logicpwn.core.exploit_engine.exploit_engine.load_exploit_chain_from_file
   :no-index:
.. autofunction:: logicpwn.core.exploit_engine.exploit_engine.extract_data_from_response
   :no-index:

Session State, Retries, Caching, and Logging
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- **Session state**: Data extracted at each step is stored and passed to subsequent steps, enabling chained logic and dynamic payloads.
- **Retries**: Each step can specify a retry count; failed steps are retried up to this limit.
- **Caching**: Responses are cached for efficiency and to avoid redundant requests.
- **Logging**: All steps, requests, responses, and validation results are logged for audit and debugging.

Advanced YAML/JSON Config Example
---------------------------------

.. code-block:: yaml

   exploit_chain:
     name: "Privilege Escalation Chain"
     description: "Escalate privileges via multi-step attack."
     parallel_execution: true
     session_state: {}
     steps:
       - name: "Login as User"
         request_config:
           method: "POST"
           url: "https://api.example.com/login"
           json_data:
             username: "user"
             password: "pass"
         retry_count: 2
         critical: true
         success_indicators:
           - "status_code == 200"
           - "token in response.json"
         data_extractors:
           token: "json:token"
       - name: "Access Admin Panel"
         request_config:
           method: "GET"
           url: "https://api.example.com/admin"
           headers:
             Authorization: "Bearer {{token}}"
         retry_count: 1
         critical: false
         success_indicators:
           - "status_code == 200"
           - "py:'admin' in response.text"
         delay_after_step: 1

Advanced Python Usage Example
-----------------------------

.. code-block:: python

   from logicpwn.core.exploit_engine.exploit_engine import load_exploit_chain_from_file, run_exploit_chain, async_run_exploit_chain
   import requests
   import asyncio

   # Load chain from YAML
   chain = load_exploit_chain_from_file("examples/exploits/priv_esc_chain.yaml")

   # Synchronous execution with error handling
   session = requests.Session()
   try:
       results = run_exploit_chain(session, chain)
       for result in results:
           print(f"Step: {result.step_name}, Status: {result.status}, Time: {result.execution_time:.2f}s")
   except Exception as e:
       print(f"Chain execution failed: {e}")

   # Asynchronous execution with parallel steps
   async def main():
       await async_run_exploit_chain(session, chain)

   asyncio.run(main())

See Also
--------
- :doc:`access_detection` for IDOR/access control automation
