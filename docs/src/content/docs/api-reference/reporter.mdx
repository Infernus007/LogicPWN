---
title: Reporter
description: LogicPWN Reporter - Enhanced for Indian Law Enforcement
category: Reporting & Compliance
sidebar:
  order: 89
---

import { Code, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

**Category:** Reporting & Compliance
**Navigation:** [API Reference](../)

LogicPWN Reporter - Enhanced for Indian Law Enforcement

This module provides comprehensive reporting capabilities for LogicPWN
penetration testing results, with specialized support for Indian law
enforcement agencies and cybersecurity compliance frameworks.

## Import

```python
import logicpwn.core.reporter
# or
from logicpwn.core.reporter import *
```


## Quick Examples

### Basic Usage

```python
from logicpwn.core.exploit_engine import load_exploit_chain_from_file, run_exploit_chain
import requests

# Load and execute a simple exploit chain
session = requests.Session()
chain = load_exploit_chain_from_file("examples/simple_exploit_corrected.yaml")
results = run_exploit_chain(session, chain)

# Analyze results
for result in results:
    print(f"Step: {result.step_name}")
    print(f"Status: {result.status}")
    print(f"Time: {result.execution_time:.2f}s")
```

### Real-World IDOR Testing

```python
from logicpwn.core.access import detect_idor_flaws
from logicpwn.core.auth import AuthConfig, authenticate_session

# Setup authentication
auth_config = AuthConfig(
    url="https://api.example.com/login",
    credentials={"username": "user", "password": "pass"},
    success_indicators=["access_token"]
)

session = authenticate_session(auth_config)

# Test for IDOR vulnerabilities
results = detect_idor_flaws(
    session,
    "https://api.example.com/users/{id}/profile",
    test_ids=["1", "2", "3", "admin", "999"],
    success_indicators=["user_data", "profile"],
    failure_indicators=["unauthorized", "403"]
)
```


## Classes

:::note[Available Classes]
This module provides 45 class(es) for reporting & compliance.
:::

### AdvancedRedactor

<Tabs>
<TabItem label="Overview">

```python
class AdvancedRedactor (SensitiveDataRedactor):
    """
    Redactor that supports custom regex-based redaction rules in addition to global sensitive patterns
    """
```

Redactor that supports custom regex-based redaction rules in addition to global sensitive patterns.
Inherits from SensitiveDataRedactor and applies user-defined RedactionRule patterns.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, custom_rules: list[logicpwn.core.reporter.models.RedactionRule] = None)
```

Initialize a new instance of `AdvancedRedactor`.

</TabItem>
</Tabs>

#### Methods

##### redact_form_data

:::note[Method]
Instance method
:::

```python
def redact_form_data(self, data: dict[str, typing.Any]) -> dict[str, typing.Any]
```

Documentation for `redact_form_data` is not available.

##### redact_headers

:::note[Method]
Instance method
:::

```python
def redact_headers(self, headers: dict[str, str]) -> dict[str, str]
```

Documentation for `redact_headers` is not available.

##### redact_json_body

:::note[Method]
Instance method
:::

```python
def redact_json_body(self, body: Union[str, dict, list]) -> str
```

Documentation for `redact_json_body` is not available.

##### redact_string_body

:::note[Method]
Instance method
:::

```python
def redact_string_body(self, content: str) -> str
```

Redact sensitive data from a string using both built-in and custom rules.
:param content: The string content to redact.
:return: Redacted string.

##### redact_url_params

:::note[Method]
Instance method
:::

```python
def redact_url_params(self, url: str) -> str
```

Documentation for `redact_url_params` is not available.


---

### AttackComplexity

<Tabs>
<TabItem label="Overview">

```python
class AttackComplexity (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 Attack Complexity metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `AttackComplexity`.

</TabItem>
</Tabs>


---

### AttackVector

<Tabs>
<TabItem label="Overview">

```python
class AttackVector (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 Attack Vector metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `AttackVector`.

</TabItem>
</Tabs>


---

### AuditLogger

<Tabs>
<TabItem label="Overview">

```python
class AuditLogger:
    """
    Centralized audit logging for security events
    """
```

Centralized audit logging for security events.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self)
```

Initialize a new instance of `AuditLogger`.

</TabItem>
</Tabs>

#### Methods

##### get_audit_log

:::note[Method]
Instance method
:::

```python
def get_audit_log(self, user_id: str = None, event_type: str = None) -> list[dict[str, typing.Any]]
```

Retrieve audit log entries.

##### log_event

:::note[Method]
Instance method
:::

```python
def log_event(self, event_type: str, user_id: str = None, details: dict[str, typing.Any] = None)
```

Log a security event.


---

### AuthenticationError

<Tabs>
<TabItem label="Overview">

```python
class AuthenticationError (Exception):
    """
    Authentication related errors
    """
```

Authentication related errors.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, *args, **kwargs)
```

Initialize a new instance of `AuthenticationError`.

</TabItem>
</Tabs>


---

### AuthorizationError

<Tabs>
<TabItem label="Overview">

```python
class AuthorizationError (Exception):
    """
    Authorization related errors
    """
```

Authorization related errors.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, *args, **kwargs)
```

Initialize a new instance of `AuthorizationError`.

</TabItem>
</Tabs>


---

### CVSSCalculator

<Tabs>
<TabItem label="Overview">

```python
class CVSSCalculator:
    """
    NIST-compliant CVSS v3
    """
```

NIST-compliant CVSS v3.1 Calculator

Implements the official CVSS v3.1 specification as defined by:
- NIST Special Publication 800-126 Rev. 3
- CVSS v3.1 Specification Document
- Common Vulnerability Scoring System v3.1: Examples & Formulas

Provides accurate, standardized vulnerability scoring for security assessments.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, *args, **kwargs)
```

Initialize a new instance of `CVSSCalculator`.

</TabItem>
</Tabs>

#### Methods

##### calculate_cvss_score

:::note[Method]
Instance method
:::

```python
def calculate_cvss_score(attack_vector: str = 'Network', attack_complexity: str = 'Low', privileges_required: str = 'None', user_interaction: str = 'None', scope: str = 'Unchanged', confidentiality: str = 'High', integrity: str = 'High', availability: str = 'High', **kwargs) -> float
```

Calculate NIST-compliant CVSS v3.1 base score.

**Args:**
- **attack_vector**: Network, Adjacent, Local, or Physical

- **attack_complexity**: Low or High

- **privileges_required**: None, Low, or High

- **user_interaction**: None or Required

- **scope**: Unchanged or Changed

- **confidentiality**: None, Low, or High

- **integrity**: None, Low, or High

- **availability**: None, Low, or High

- ****kwargs**: Additional parameters for backward compatibility

**Returns:**

- **float**: CVSS v3.1 base score (0.0-10.0)

**Raises:**

- **ValueError**: If invalid metric values are provided

##### calculate_full_score

:::note[Method]
Instance method
:::

```python
def calculate_full_score(vector: logicpwn.core.reporter.cvss.CVSSVector) -> logicpwn.core.reporter.cvss.CVSSScore
```

Calculate complete NIST-compliant CVSS v3.1 score with all components.

**Args:**
- **vector**: CVSS vector with all metric values

**Returns:**

- **CVSSScore**: Complete score with subscores and metadata

##### validate_vector_string

:::note[Method]
Instance method
:::

```python
def validate_vector_string(vector_string: str) -> bool
```

Validate CVSS v3.1 vector string format.

**Args:**
- **vector_string**: CVSS vector string to validate

**Returns:**

- **bool**: True if valid, False otherwise


---

### CVSSVector

<Tabs>
<TabItem label="Overview">

```python
class CVSSVector (BaseModel):
    """
    NIST-compliant CVSS v3
    """
```

NIST-compliant CVSS v3.1 vector representation

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `CVSSVector`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### to_vector_string

:::note[Method]
Instance method
:::

```python
def to_vector_string(self) -> str
```

Generate CVSS v3.1 vector string

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.

##### validate_enum_values

:::note[Method]
Instance method
:::

```python
def validate_enum_values(v)
```

Validate that string inputs match enum values


---

### ComplianceMapping

<Tabs>
<TabItem label="Overview">

```python
class ComplianceMapping:
    """
    Maps vulnerabilities to compliance requirements
    """
```

Maps vulnerabilities to compliance requirements

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, framework: logicpwn.core.reporter.indian_compliance.IndianComplianceFramework, requirement: logicpwn.core.reporter.framework_mapper.FrameworkRequirement, requirement_id: str, description: str, compliance_status: logicpwn.core.reporter.framework_mapper.ComplianceStatus, evidence_required: list[str], remediation_actions: list[str], legal_implications: Optional[str] = None, priority_level: str = 'medium') -> None
```

Initialize a new instance of `ComplianceMapping`.

</TabItem>
</Tabs>


---

### ComplianceStatus

<Tabs>
<TabItem label="Overview">

```python
class ComplianceStatus (Enum):
    """
    Compliance status levels
    """
```

Compliance status levels

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `ComplianceStatus`.

</TabItem>
</Tabs>


---

### FrameworkRequirement

<Tabs>
<TabItem label="Overview">

```python
class FrameworkRequirement (Enum):
    """
    Standard framework requirements
    """
```

Standard framework requirements

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `FrameworkRequirement`.

</TabItem>
</Tabs>


---

### ImpactMetric

<Tabs>
<TabItem label="Overview">

```python
class ImpactMetric (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 Impact metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `ImpactMetric`.

</TabItem>
</Tabs>


---

### IndianComplianceChecker

<Tabs>
<TabItem label="Overview">

```python
class IndianComplianceChecker:
    """
    Checks vulnerabilities against Indian compliance frameworks
    """
```

Checks vulnerabilities against Indian compliance frameworks

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self)
```

Initialize a new instance of `IndianComplianceChecker`.

</TabItem>
</Tabs>

#### Methods

##### classify_vulnerability

:::note[Method]
Instance method
:::

```python
def classify_vulnerability(self, finding: logicpwn.core.reporter.orchestrator.VulnerabilityFinding) -> logicpwn.core.reporter.indian_compliance.IndianVulnerabilityFinding
```

Classify vulnerability according to Indian legal and compliance frameworks

##### generate_chain_of_custody_document

:::note[Method]
Instance method
:::

```python
def generate_chain_of_custody_document(self, finding: logicpwn.core.reporter.indian_compliance.IndianVulnerabilityFinding, investigating_officer: str) -> dict[str, typing.Any]
```

Generate chain of custody documentation for digital evidence

##### generate_legal_impact_assessment

:::note[Method]
Instance method
:::

```python
def generate_legal_impact_assessment(self, finding: logicpwn.core.reporter.indian_compliance.IndianVulnerabilityFinding) -> dict[str, typing.Any]
```

Generate comprehensive legal impact assessment


---

### IndianComplianceFramework

<Tabs>
<TabItem label="Overview">

```python
class IndianComplianceFramework (Enum):
    """
    Indian cybersecurity compliance frameworks
    """
```

Indian cybersecurity compliance frameworks

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `IndianComplianceFramework`.

</TabItem>
</Tabs>


---

### IndianComplianceMapping

<Tabs>
<TabItem label="Overview">

```python
class IndianComplianceMapping:
    """
    Maps vulnerabilities to Indian legal and compliance frameworks
    """
```

Maps vulnerabilities to Indian legal and compliance frameworks

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, framework: logicpwn.core.reporter.indian_compliance.IndianComplianceFramework, threat_classification: logicpwn.core.reporter.indian_compliance.ThreatClassification, legal_sections: list[logicpwn.core.reporter.indian_compliance.LegalSeverity], compliance_requirements: list[str], remediation_standards: list[str], reporting_requirements: dict[str, typing.Any]) -> None
```

Initialize a new instance of `IndianComplianceMapping`.

</TabItem>
</Tabs>


---

### IndianFrameworkMapper

<Tabs>
<TabItem label="Overview">

```python
class IndianFrameworkMapper:
    """
    Maps vulnerabilities to Indian cybersecurity frameworks
    """
```

Maps vulnerabilities to Indian cybersecurity frameworks

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self)
```

Initialize a new instance of `IndianFrameworkMapper`.

</TabItem>
</Tabs>

#### Methods

##### generate_compliance_matrix

:::note[Method]
Instance method
:::

```python
def generate_compliance_matrix(self, vulnerabilities: list[dict[str, typing.Any]]) -> dict[str, typing.Any]
```

Generate comprehensive compliance matrix

##### map_vulnerability_to_frameworks

:::note[Method]
Instance method
:::

```python
def map_vulnerability_to_frameworks(self, vulnerability_type: str, severity: str) -> list[logicpwn.core.reporter.framework_mapper.ComplianceMapping]
```

Map a vulnerability to relevant framework requirements


---

### IndianLawEnforcementConfig

<Tabs>
<TabItem label="Overview">

```python
class IndianLawEnforcementConfig:
    """
    Configuration specific to Indian law enforcement reporting
    """
```

Configuration specific to Indian law enforcement reporting

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, investigating_agency: str, fir_number: Optional[str] = None, case_reference: Optional[str] = None, investigating_officer: str = '', jurisdiction: str = '', incident_classification: str = 'cyber_crime', priority_level: str = 'medium', legal_authorization: str = '', digital_forensics_team: Optional[str] = None, evidence_collection_protocols: list[str] = <factory>, compliance_frameworks: list[logicpwn.core.reporter.indian_compliance.IndianComplianceFramework] = <factory>, include_chain_of_custody: bool = True, include_legal_analysis: bool = True, include_remediation_timeline: bool = True, redaction_level: str = 'standard') -> None
```

Initialize a new instance of `IndianLawEnforcementConfig`.

</TabItem>
</Tabs>


---

### IndianLawEnforcementReportGenerator

<Tabs>
<TabItem label="Overview">

```python
class IndianLawEnforcementReportGenerator (ReportGenerator):
    """
    Enhanced report generator for Indian law enforcement agencies
    """
```

Enhanced report generator for Indian law enforcement agencies

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, config: logicpwn.core.reporter.orchestrator.ReportConfig, law_enforcement_config: logicpwn.core.reporter.indian_law_enforcement.IndianLawEnforcementConfig)
```

Initialize a new instance of `IndianLawEnforcementReportGenerator`.

</TabItem>
</Tabs>

#### Methods

##### add_finding

:::note[Method]
Instance method
:::

```python
def add_finding(self, finding_data: dict) -> None
```

Add finding with legacy interface.

##### add_finding_with_compliance

:::note[Method]
Instance method
:::

```python
def add_finding_with_compliance(self, finding: logicpwn.core.reporter.orchestrator.VulnerabilityFinding) -> logicpwn.core.reporter.indian_compliance.IndianVulnerabilityFinding
```

Add a finding and automatically classify for Indian compliance

##### add_redaction_rule

:::note[Method]
Instance method
:::

```python
def add_redaction_rule(self, rule: logicpwn.core.reporter.models.RedactionRule) -> None
```

Add redaction rule (legacy compatibility).

##### calculate_risk_score

:::note[Method]
Instance method
:::

```python
def calculate_risk_score(self) -> float
```

Calculate overall risk score based on findings.

##### enable_security_features

:::note[Method]
Instance method
:::

```python
def enable_security_features(self, auth_manager: logicpwn.core.reporter.auth_manager.ReportAuthManager = None) -> logicpwn.core.reporter.orchestrator.SecureReportGenerator
```

Enable enhanced security features.

**Returns:**
 SecureReportGenerator instance for advanced security features

##### export_law_enforcement_package

:::note[Method]
Instance method
:::

```python
def export_law_enforcement_package(self, output_dir: str) -> dict[str, str]
```

Export complete law enforcement package with multiple formats

##### export_to_file

:::note[Method]
Instance method
:::

```python
def export_to_file(self, filepath: str, format: str, template_dir: Optional[str] = None) -> None
```

Export report to file with legacy interface.

##### generate_comprehensive_law_enforcement_report

:::note[Method]
Instance method
:::

```python
def generate_comprehensive_law_enforcement_report(self) -> dict[str, typing.Any]
```

Generate comprehensive report for law enforcement

##### wrapper

:::note[Method]
Instance method
:::

```python
def wrapper(*args, **kwargs)
```

Documentation for `wrapper` is not available.

##### get_audit_log

:::note[Method]
Instance method
:::

```python
def get_audit_log(self) -> list
```

Get audit log if available.

##### get_findings_summary

:::note[Method]
Instance method
:::

```python
def get_findings_summary(self) -> dict
```

Get summary of findings by severity.

##### set_metadata

:::note[Method]
Instance method
:::

```python
def set_metadata(self, metadata: logicpwn.core.reporter.orchestrator.ReportMetadata) -> None
```

Set report metadata.


---

### IndianReportMetadata

<Tabs>
<TabItem label="Overview">

```python
class IndianReportMetadata (ReportMetadata):
    """
    Extended report metadata for Indian law enforcement
    """
```

Extended report metadata for Indian law enforcement

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `IndianReportMetadata`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### IndianVulnerabilityFinding

<Tabs>
<TabItem label="Overview">

```python
class IndianVulnerabilityFinding (VulnerabilityFinding):
    """
    Extended vulnerability finding with Indian compliance data
    """
```

Extended vulnerability finding with Indian compliance data

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `IndianVulnerabilityFinding`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### InputValidator

<Tabs>
<TabItem label="Overview">

```python
class InputValidator:
    """
    Main input validator for the reporter module
    """
```

Main input validator for the reporter module.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, *args, **kwargs)
```

Initialize a new instance of `InputValidator`.

</TabItem>
</Tabs>

#### Methods

##### sanitize_dict_values

:::note[Method]
Instance method
:::

```python
def sanitize_dict_values(data: dict[str, typing.Any], max_depth: int = 3) -> dict[str, typing.Any]
```

Recursively sanitize dictionary values.

##### validate_file_path

:::note[Method]
Instance method
:::

```python
def validate_file_path(file_path: str) -> str
```

Validate file path for security.

##### validate_report_config

:::note[Method]
Instance method
:::

```python
def validate_report_config(data: dict[str, typing.Any]) -> logicpwn.core.reporter.input_validator.ReportConfigInput
```

Validate report configuration input data.

##### validate_report_format

:::note[Method]
Instance method
:::

```python
def validate_report_format(format_type: str) -> str
```

Validate report format.

##### validate_template_content

:::note[Method]
Instance method
:::

```python
def validate_template_content(content: str) -> str
```

Validate template content for security.

##### validate_vulnerability_finding

:::note[Method]
Instance method
:::

```python
def validate_vulnerability_finding(data: dict[str, typing.Any]) -> logicpwn.core.reporter.input_validator.VulnerabilityInput
```

Validate vulnerability finding input data.


---

### LegalSeverity

<Tabs>
<TabItem label="Overview">

```python
class LegalSeverity (Enum):
    """
    Legal severity classification for Indian law enforcement
    """
```

Legal severity classification for Indian law enforcement

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `LegalSeverity`.

</TabItem>
</Tabs>


---

### LogicPWNIndianLawEnforcementIntegrator

<Tabs>
<TabItem label="Overview">

```python
class LogicPWNIndianLawEnforcementIntegrator:
    """
    Main integration class that connects LogicPWN testing capabilities
with Indian law enforcement reporting requirements
    """
```

Main integration class that connects LogicPWN testing capabilities
```python
with Indian law enforcement reporting requirements.
```

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, law_enforcement_config: logicpwn.core.reporter.indian_law_enforcement.IndianLawEnforcementConfig)
```

Initialize a new instance of `LogicPWNIndianLawEnforcementIntegrator`.

</TabItem>
</Tabs>

#### Methods

##### create_report_config

:::note[Method]
Instance method
:::

```python
def create_report_config(self, target_url: str, report_title: str = None) -> logicpwn.core.reporter.orchestrator.ReportConfig
```

Create a report configuration for Indian law enforcement

##### generate_law_enforcement_report

:::note[Method]
Instance method
:::

```python
def generate_law_enforcement_report(self, target_url: str, output_dir: str = './reports') -> dict[str, str]
```

Generate comprehensive law enforcement report

##### run_comprehensive_security_assessment

:::note[Method]
Instance method
:::

```python
def run_comprehensive_security_assessment(self, target_url: str, auth_config: Optional[logicpwn.core.auth.auth_models.AuthConfig] = None, test_endpoints: Optional[list[str]] = None, test_ids: Optional[list[str]] = None) -> dict[str, typing.Any]
```

Run comprehensive security assessment using LogicPWN capabilities
and generate findings for law enforcement reporting.

##### run_stress_test_for_evidence

:::note[Method]
Instance method
:::

```python
def run_stress_test_for_evidence(self, target_urls: list[str], duration: int = 30, max_concurrent: int = 10) -> dict[str, typing.Any]
```

Run stress test to gather performance evidence


---

### Permission

<Tabs>
<TabItem label="Overview">

```python
class Permission (str, Enum):
    """
    Report access permissions
    """
```

Report access permissions.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `Permission`.

</TabItem>
</Tabs>


---

### PrivilegesRequired

<Tabs>
<TabItem label="Overview">

```python
class PrivilegesRequired (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 Privileges Required metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `PrivilegesRequired`.

</TabItem>
</Tabs>


---

### RedactionRule

<Tabs>
<TabItem label="Overview">

```python
class RedactionRule (BaseModel):
    """
    !!! abstract "Usage Documentation"
    [Models](
    """
```

!!! abstract "Usage Documentation"

A base class for creating Pydantic models.

Attributes:
 __class_vars__: The names of the class variables defined on the model.
 __private_attributes__: Metadata about the private attributes of the model.
 __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

 __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 __pydantic_core_schema__: The core schema of the model.
 __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 __pydantic_decorators__: Metadata containing the decorators defined on the model.
 This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 __pydantic_post_init__: The name of the post-init method for the model, if defined.
 __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

 __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

 __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 is set to `'allow'`.
 __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 __pydantic_private__: Values of private attributes set on the model instance.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `RedactionRule`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### ReportAuthManager

<Tabs>
<TabItem label="Overview">

```python
class ReportAuthManager:
    """
    Authentication and authorization manager for reports
    """
```

Authentication and authorization manager for reports.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, secret_key: Optional[str] = None, enable_encryption: bool = True)
```

Initialize a new instance of `ReportAuthManager`.

</TabItem>
</Tabs>

#### Methods

##### authenticate_api_key

:::note[Method]
Instance method
:::

```python
def authenticate_api_key(self, api_key: str) -> logicpwn.core.reporter.auth_manager.User
```

Authenticate using API key.

##### authenticate_jwt

:::note[Method]
Instance method
:::

```python
def authenticate_jwt(self, token: str) -> logicpwn.core.reporter.auth_manager.User
```

Authenticate using JWT token.

##### authenticate_user

:::note[Method]
Instance method
:::

```python
def authenticate_user(self, username: str, password: str, ip_address: str = None, user_agent: str = None) -> logicpwn.core.reporter.auth_manager.Session
```

Authenticate user and create session.

##### check_permission

:::note[Method]
Instance method
:::

```python
def check_permission(self, user: logicpwn.core.reporter.auth_manager.User, permission: logicpwn.core.reporter.auth_manager.Permission) -> bool
```

Check if user has specific permission.

##### cleanup_expired_sessions

:::note[Method]
Instance method
:::

```python
def cleanup_expired_sessions(self)
```

Remove expired sessions.

##### create_session

:::note[Method]
Instance method
:::

```python
def create_session(self, user: logicpwn.core.reporter.auth_manager.User, ip_address: str = None, user_agent: str = None) -> str
```

Create a new session for user.

##### create_user

:::note[Method]
Instance method
:::

```python
def create_user(self, username: str, email: str, password: str, roles: set[logicpwn.core.reporter.auth_manager.Role] = None) -> logicpwn.core.reporter.auth_manager.User
```

Create new user.

##### decrypt_sensitive_data

:::note[Method]
Instance method
:::

```python
def decrypt_sensitive_data(self, encrypted_data: str) -> str
```

Decrypt sensitive data.

##### encrypt_sensitive_data

:::note[Method]
Instance method
:::

```python
def encrypt_sensitive_data(self, data: str) -> str
```

Encrypt sensitive data.

##### generate_api_key

:::note[Method]
Instance method
:::

```python
def generate_api_key(self, user_id: str) -> str
```

Generate API key for user.

##### generate_jwt_token

:::note[Method]
Instance method
:::

```python
def generate_jwt_token(self, user: logicpwn.core.reporter.auth_manager.User, expires_in: int = 3600) -> str
```

Generate JWT token for user.

##### get_user_summary

:::note[Method]
Instance method
:::

```python
def get_user_summary(self, user: logicpwn.core.reporter.auth_manager.User) -> dict[str, typing.Any]
```

Get user summary for logging/audit.

##### logout

:::note[Method]
Instance method
:::

```python
def logout(self, session_id: str)
```

Logout user session.

##### register_user

:::note[Method]
Instance method
:::

```python
def register_user(self, username: str, password: str, email: str = None, roles: set[logicpwn.core.reporter.auth_manager.Role] = None, role: logicpwn.core.reporter.auth_manager.Role = None) -> logicpwn.core.reporter.auth_manager.User
```

Register a new user (alias for create_user).

##### require_permission

:::note[Method]
Instance method
:::

```python
def require_permission(self, user: logicpwn.core.reporter.auth_manager.User, permission: logicpwn.core.reporter.auth_manager.Permission)
```

Require user to have specific permission.

##### validate_session

:::note[Method]
Instance method
:::

```python
def validate_session(self, session_id: str) -> Optional[logicpwn.core.reporter.auth_manager.User]
```

Validate session and return user.


---

### ReportConfig

<Tabs>
<TabItem label="Overview">

```python
class ReportConfig (BaseModel):
    """
    Configuration for report generation, including output style, redaction, and branding
    """
```

Configuration for report generation, including output style, redaction, and branding.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ReportConfig`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### ReportConfigInput

<Tabs>
<TabItem label="Overview">

```python
class ReportConfigInput (ValidatedInput):
    """
    Validated input for report configuration
    """
```

Validated input for report configuration.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ReportConfigInput`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.

##### validate_target_url

:::note[Method]
Instance method
:::

```python
def validate_target_url(v)
```

Documentation for `validate_target_url` is not available.

##### validate_title

:::note[Method]
Instance method
:::

```python
def validate_title(v)
```

Documentation for `validate_title` is not available.

##### validate_user

:::note[Method]
Instance method
:::

```python
def validate_user(v)
```

Documentation for `validate_user` is not available.


---

### ReportGenerator

<Tabs>
<TabItem label="Overview">

```python
class ReportGenerator:
    """
    Legacy ReportGenerator class for backward compatibility
    """
```

Legacy ReportGenerator class for backward compatibility.
Wraps SecureReportGenerator with default security settings.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, config: logicpwn.core.reporter.orchestrator.ReportConfig)
```

Initialize a new instance of `ReportGenerator`.

</TabItem>
</Tabs>

#### Methods

##### add_finding

:::note[Method]
Instance method
:::

```python
def add_finding(self, finding_data: dict) -> None
```

Add finding with legacy interface.

##### add_redaction_rule

:::note[Method]
Instance method
:::

```python
def add_redaction_rule(self, rule: logicpwn.core.reporter.models.RedactionRule) -> None
```

Add redaction rule (legacy compatibility).

##### calculate_risk_score

:::note[Method]
Instance method
:::

```python
def calculate_risk_score(self) -> float
```

Calculate overall risk score based on findings.

##### enable_security_features

:::note[Method]
Instance method
:::

```python
def enable_security_features(self, auth_manager: logicpwn.core.reporter.auth_manager.ReportAuthManager = None) -> logicpwn.core.reporter.orchestrator.SecureReportGenerator
```

Enable enhanced security features.

**Returns:**
 SecureReportGenerator instance for advanced security features

##### export_to_file

:::note[Method]
Instance method
:::

```python
def export_to_file(self, filepath: str, format: str, template_dir: Optional[str] = None) -> None
```

Export report to file with legacy interface.

##### wrapper

:::note[Method]
Instance method
:::

```python
def wrapper(*args, **kwargs)
```

Documentation for `wrapper` is not available.

##### get_audit_log

:::note[Method]
Instance method
:::

```python
def get_audit_log(self) -> list
```

Get audit log if available.

##### get_findings_summary

:::note[Method]
Instance method
:::

```python
def get_findings_summary(self) -> dict
```

Get summary of findings by severity.

##### set_metadata

:::note[Method]
Instance method
:::

```python
def set_metadata(self, metadata: logicpwn.core.reporter.orchestrator.ReportMetadata) -> None
```

Set report metadata.


---

### ReportMetadata

<Tabs>
<TabItem label="Overview">

```python
class ReportMetadata (BaseModel):
    """
    Metadata for a vulnerability report, including scan details and summary stats
    """
```

Metadata for a vulnerability report, including scan details and summary stats.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ReportMetadata`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### ReportSecurityMiddleware

<Tabs>
<TabItem label="Overview">

```python
class ReportSecurityMiddleware:
    """
    Security middleware for report operations
    """
```

Security middleware for report operations.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, policy: logicpwn.core.reporter.security_middleware.SecurityPolicy = None)
```

Initialize a new instance of `ReportSecurityMiddleware`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>require_authentication</code></summary>

Decorator to require authentication for report operations.

</details>

#### Methods

##### add_security_headers

:::note[Method]
Instance method
:::

```python
def add_security_headers(self, content: str, content_type: str = 'html') -> str
```

Add security headers to content.

##### authenticate_request

:::note[Method]
Instance method
:::

```python
def authenticate_request(self, auth_token: str = None, api_key: str = None, session_id: str = None, username: str = None, password: str = None) -> dict[str, typing.Any]
```

Authenticate a request using various methods.

**Returns:**
 Dict containing user context or raises exception

##### authorize_operation

:::note[Method]
Instance method
:::

```python
def authorize_operation(self, user_context: dict[str, typing.Any], required_permission: str) -> bool
```

Check if user is authorized for operation.

##### decrypt_sensitive_data

:::note[Method]
Instance method
:::

```python
def decrypt_sensitive_data(self, encrypted_data: str) -> str
```

Decrypt sensitive data.

##### encrypt_sensitive_data

:::note[Method]
Instance method
:::

```python
def encrypt_sensitive_data(self, data: str) -> str
```

Encrypt sensitive data.

##### log_operation

:::note[Method]
Instance method
:::

```python
def log_operation(self, operation: str, user_id: str = None, details: dict[str, typing.Any] = None)
```

Log a report operation.

##### validate_input

:::note[Method]
Instance method
:::

```python
def validate_input(self, input_data: Any, input_type: str = 'generic') -> Any
```

Validate and sanitize input data.


---

### Role

<Tabs>
<TabItem label="Overview">

```python
class Role (str, Enum):
    """
    User roles for report access
    """
```

User roles for report access.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `Role`.

</TabItem>
</Tabs>


---

### Scope

<Tabs>
<TabItem label="Overview">

```python
class Scope (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 Scope metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `Scope`.

</TabItem>
</Tabs>


---

### SecureReportConfig

<Tabs>
<TabItem label="Overview">

```python
class SecureReportConfig (BaseModel):
    """
    Security-enhanced report configuration with input validation
    """
```

Security-enhanced report configuration with input validation.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `SecureReportConfig`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_dict

:::note[Method]
Instance method
:::

```python
def from_dict(data: dict) -> 'SecureReportConfig'
```

Create from dictionary with input validation.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### SecureReportGenerator

<Tabs>
<TabItem label="Overview">

```python
class SecureReportGenerator:
    """
    Security-enhanced report generator with authentication, input validation, and audit logging
    """
```

Security-enhanced report generator with authentication, input validation, and audit logging.
Provides comprehensive security controls for vulnerability report generation.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, config: logicpwn.core.reporter.orchestrator.ReportConfig, auth_manager: Optional[logicpwn.core.reporter.auth_manager.ReportAuthManager] = None)
```

Initialize a new instance of `SecureReportGenerator`.

</TabItem>
</Tabs>

#### Methods

##### add_finding

:::note[Method]
Instance method
:::

```python
def add_finding(self, finding_data: dict, user: logicpwn.core.reporter.auth_manager.User = None) -> None
```

Add a vulnerability finding with security validation.

**Args:**
- **finding_data**: Raw finding data (will be validated)

- **user**: Authenticated user (if None, will use default)

##### authenticate_user

:::note[Method]
Instance method
:::

```python
def authenticate_user(self, auth_token: str = None, api_key: str = None, session_id: str = None) -> logicpwn.core.reporter.auth_manager.User
```

Authenticate user for report access.

**Args:**
- **auth_token**: JWT authentication token

- **api_key**: API key for authentication

- **session_id**: Session ID for authentication

**Returns:**
 Authenticated user

**Raises:**

- **AuthenticationError**: If authentication fails

##### encrypt_sensitive_findings

:::note[Method]
Instance method
:::

```python
def encrypt_sensitive_findings(self, user: logicpwn.core.reporter.auth_manager.User = None) -> None
```

Encrypt sensitive data in findings.

**Args:**
- **user**: Authenticated user

##### export_to_file

:::note[Method]
Instance method
:::

```python
def export_to_file(self, filepath: str, format: str, user: logicpwn.core.reporter.auth_manager.User = None, template_dir: Optional[str] = None) -> None
```

Export report to file with security validation.

**Args:**
- **filepath**: Output file path (will be validated)

- **format**: Report format

- **user**: Authenticated user

- **template_dir**: Optional template directory

##### wrapper

:::note[Method]
Instance method
:::

```python
def wrapper(*args, **kwargs)
```

Documentation for `wrapper` is not available.

##### get_audit_log

:::note[Method]
Instance method
:::

```python
def get_audit_log(self, user: logicpwn.core.reporter.auth_manager.User = None) -> list
```

Get audit log entries.

**Args:**
- **user**: Authenticated user

**Returns:**
 List of audit log entries

**Raises:**

- **AuthorizationError**: If user lacks audit permissions


---

### SecureVulnerabilityFinding

<Tabs>
<TabItem label="Overview">

```python
class SecureVulnerabilityFinding (BaseModel):
    """
    Security-enhanced vulnerability finding with input validation
    """
```

Security-enhanced vulnerability finding with input validation.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `SecureVulnerabilityFinding`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_dict

:::note[Method]
Instance method
:::

```python
def from_dict(data: dict) -> 'SecureVulnerabilityFinding'
```

Create from dictionary with input validation.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### SecurityPolicy

<Tabs>
<TabItem label="Overview">

```python
class SecurityPolicy:
    """
    Security policy configuration for report operations
    """
```

Security policy configuration for report operations.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self)
```

Initialize a new instance of `SecurityPolicy`.

</TabItem>
</Tabs>


---

### TemplateRenderer

<Tabs>
<TabItem label="Overview">

```python
class TemplateRenderer:
    """
    Utility for rendering report templates using Jinja2 if available, or string replacement fallback
    """
```

Utility for rendering report templates using Jinja2 if available, or string replacement fallback.
Supports custom template directories for branding and localization.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, template_dir: str = 'logicpwn/templates')
```

Initialize a new instance of `TemplateRenderer`.

</TabItem>
</Tabs>

#### Methods

##### render

:::note[Method]
Instance method
:::

```python
def render(self, template_name: str, context: dict[str, typing.Any]) -> str
```

Render a template with the given context.
Uses Jinja2 if available, otherwise falls back to string replacement.
:param template_name: Name of the template file.
:param context: Dictionary of variables for template rendering.
:return: Rendered string.


---

### ThreatClassification

<Tabs>
<TabItem label="Overview">

```python
class ThreatClassification (Enum):
    """
    Threat classification as per Indian security standards
    """
```

Threat classification as per Indian security standards

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `ThreatClassification`.

</TabItem>
</Tabs>


---

### User

<Tabs>
<TabItem label="Overview">

```python
class User:
    """
    User representation for authentication
    """
```

User representation for authentication.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, user_id: str, username: str, email: str, roles: set[logicpwn.core.reporter.auth_manager.Role] = None, role: logicpwn.core.reporter.auth_manager.Role = None, permissions: set[logicpwn.core.reporter.auth_manager.Permission] = None, created_at: datetime.datetime = None, last_login: datetime.datetime = None, is_active: bool = True, failed_login_attempts: int = 0, locked_until: datetime.datetime = None)
```

Initialize a new instance of `User`.

</TabItem>
</Tabs>

#### Methods

##### has_permission

:::note[Method]
Instance method
:::

```python
def has_permission(self, permission: logicpwn.core.reporter.auth_manager.Permission) -> bool
```

Check if user has specific permission.

##### has_role

:::note[Method]
Instance method
:::

```python
def has_role(self, role: logicpwn.core.reporter.auth_manager.Role) -> bool
```

Check if user has specific role.

##### is_locked

:::note[Method]
Instance method
:::

```python
def is_locked(self) -> bool
```

Check if user account is locked.

##### update_permissions

:::note[Method]
Instance method
:::

```python
def update_permissions(self)
```

Update user permissions based on assigned roles.


---

### UserInteraction

<Tabs>
<TabItem label="Overview">

```python
class UserInteraction (str, Enum):
    """
    CVSS v3
    """
```

CVSS v3.1 User Interaction metric values

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `UserInteraction`.

</TabItem>
</Tabs>


---

### ValidationError

<Tabs>
<TabItem label="Overview">

```python
class ValidationError (Exception):
    """
    Custom validation error for input validation failures
    """
```

Custom validation error for input validation failures.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, *args, **kwargs)
```

Initialize a new instance of `ValidationError`.

</TabItem>
</Tabs>


---

### VulnerabilityFinding

<Tabs>
<TabItem label="Overview">

```python
class VulnerabilityFinding (BaseModel):
    """
    Represents a single vulnerability finding for reporting
    """
```

Represents a single vulnerability finding for reporting.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `VulnerabilityFinding`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### VulnerabilityInput

<Tabs>
<TabItem label="Overview">

```python
class VulnerabilityInput (ValidatedInput):
    """
    Validated input for vulnerability findings
    """
```

Validated input for vulnerability findings.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `VulnerabilityInput`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.

##### validate_endpoints

:::note[Method]
Instance method
:::

```python
def validate_endpoints(v)
```

Documentation for `validate_endpoints` is not available.

##### validate_references

:::note[Method]
Instance method
:::

```python
def validate_references(v)
```

Documentation for `validate_references` is not available.

##### validate_severity

:::note[Method]
Instance method
:::

```python
def validate_severity(v)
```

Documentation for `validate_severity` is not available.

##### validate_text_fields

:::note[Method]
Instance method
:::

```python
def validate_text_fields(v)
```

Documentation for `validate_text_fields` is not available.


---

## Functions

:::note[Available Functions]
This module provides 4 function(s) for direct use.
:::

### create_indian_law_enforcement_assessment

:::note[Function]
Module function
:::

```python
def create_indian_law_enforcement_assessment(target_url: str, investigating_agency: str, case_reference: str, investigating_officer: str, auth_config: Optional[logicpwn.core.auth.auth_models.AuthConfig] = None, test_endpoints: Optional[list[str]] = None, test_ids: Optional[list[str]] = None, output_dir: str = './reports') -> dict[str, typing.Any]
```

Convenience function to create a complete Indian law enforcement assessment

### example_indian_law_enforcement_usage

:::note[Function]
Module function
:::

```python
def example_indian_law_enforcement_usage()
```

Example usage of Indian law enforcement integration

### require_authentication

:::note[Function]
Module function
:::

```python
def require_authentication(permission: str = 'read')
```

Decorator to require authentication for report operations.

### validate_input

:::note[Function]
Module function
:::

```python
def validate_input(input_type: str = 'generic')
```

Decorator to validate input data.


## Related Modules

:::tip[Reporting & Compliance Modules]
Explore other modules in the Reporting & Compliance category:

- **[Reporter › Compliance](./reporter/compliance)** - Indian law enforcement compliance
- **[Reporter › Law Enforcement](./reporter/law-enforcement)** - Law enforcement reports
- **[Reporter › Framework Mapper](./reporter/framework-mapper)** - Compliance framework mapping
- **[Reporter › Integration](./reporter/integration)** - Integration utilities
:::
