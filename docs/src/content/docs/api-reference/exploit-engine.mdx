---
title: Exploit Engine
description: LogicPwn Exploit Engine Module
category: Exploit Engine
sidebar:
  order: 35
---

import { Code, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

**Category:** Exploit Engine
**Navigation:** [API Reference](../)

LogicPwn Exploit Engine Module
Secure exploit chain execution with comprehensive validation.

## Import

```python
import logicpwn.core.exploit_engine
# or
from logicpwn.core.exploit_engine import *
```


## Quick Examples

### Basic Usage

```python
from logicpwn.core.exploit_engine import load_exploit_chain_from_file, run_exploit_chain
import requests

# Load and execute a simple exploit chain
session = requests.Session()
chain = load_exploit_chain_from_file("examples/simple_exploit_corrected.yaml")
results = run_exploit_chain(session, chain)

# Analyze results
for result in results:
    print(f"Step: {result.step_name}")
    print(f"Status: {result.status}")
    print(f"Time: {result.execution_time:.2f}s")
```

### Real-World IDOR Testing

```python
from logicpwn.core.access import detect_idor_flaws
from logicpwn.core.auth import AuthConfig, authenticate_session

# Setup authentication
auth_config = AuthConfig(
    url="https://api.example.com/login",
    credentials={"username": "user", "password": "pass"},
    success_indicators=["access_token"]
)

session = authenticate_session(auth_config)

# Test for IDOR vulnerabilities
results = detect_idor_flaws(
    session,
    "https://api.example.com/users/{id}/profile",
    test_ids=["1", "2", "3", "admin", "999"],
    success_indicators=["user_data", "profile"],
    failure_indicators=["unauthorized", "403"]
)
```


## Classes

:::note[Available Classes]
This module provides 7 class(es) for exploit engine.
:::

### ExploitChain

<Tabs>
<TabItem label="Overview">

```python
class ExploitChain (BaseModel):
    """
    !!! abstract "Usage Documentation"
    [Models](
    """
```

!!! abstract "Usage Documentation"

A base class for creating Pydantic models.

Attributes:
 __class_vars__: The names of the class variables defined on the model.
 __private_attributes__: Metadata about the private attributes of the model.
 __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

 __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 __pydantic_core_schema__: The core schema of the model.
 __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 __pydantic_decorators__: Metadata containing the decorators defined on the model.
 This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 __pydantic_post_init__: The name of the post-init method for the model, if defined.
 __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

 __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

 __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 is set to `'allow'`.
 __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 __pydantic_private__: Values of private attributes set on the model instance.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ExploitChain`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### ExploitLogger

<Tabs>
<TabItem label="Overview">

```python
class ExploitLogger:
    """
    Class documentation.
    """
```

The `ExploitLogger` class provides core functionality for this module.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, logger_name: str = 'logicpwn.exploit_engine')
```

Initialize a new instance of `ExploitLogger`.

</TabItem>
</Tabs>

#### Methods

##### log_chain

:::note[Method]
Instance method
:::

```python
def log_chain(self, chain_name: str, results: list[dict[str, typing.Any]])
```

Documentation for `log_chain` is not available.

##### log_error

:::note[Method]
Instance method
:::

```python
def log_error(self, step_name: str, error: str)
```

Documentation for `log_error` is not available.

##### log_info

:::note[Method]
Instance method
:::

```python
def log_info(self, message: str, data: Any = None)
```

Log informational message with optional data.

##### log_request_response

:::note[Method]
Instance method
:::

```python
def log_request_response(self, step_name: str, request: Any, response: Any)
```

Documentation for `log_request_response` is not available.

##### log_step

:::note[Method]
Instance method
:::

```python
def log_step(self, step_name: str, status: str, info: dict[str, typing.Any])
```

Documentation for `log_step` is not available.


---

### ExploitResult

<Tabs>
<TabItem label="Overview">

```python
class ExploitResult (BaseModel):
    """
    !!! abstract "Usage Documentation"
    [Models](
    """
```

!!! abstract "Usage Documentation"

A base class for creating Pydantic models.

Attributes:
 __class_vars__: The names of the class variables defined on the model.
 __private_attributes__: Metadata about the private attributes of the model.
 __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

 __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 __pydantic_core_schema__: The core schema of the model.
 __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 __pydantic_decorators__: Metadata containing the decorators defined on the model.
 This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 __pydantic_post_init__: The name of the post-init method for the model, if defined.
 __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

 __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

 __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 is set to `'allow'`.
 __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 __pydantic_private__: Values of private attributes set on the model instance.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ExploitResult`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### ExploitStatus

<Tabs>
<TabItem label="Overview">

```python
class ExploitStatus (str, Enum):
    """
    str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
    """
```

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, *args, **kwds)
```

Initialize a new instance of `ExploitStatus`.

</TabItem>
</Tabs>


---

### ExploitStep

<Tabs>
<TabItem label="Overview">

```python
class ExploitStep (BaseModel):
    """
    !!! abstract "Usage Documentation"
    [Models](
    """
```

!!! abstract "Usage Documentation"

A base class for creating Pydantic models.

Attributes:
 __class_vars__: The names of the class variables defined on the model.
 __private_attributes__: Metadata about the private attributes of the model.
 __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

 __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 __pydantic_core_schema__: The core schema of the model.
 __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 __pydantic_decorators__: Metadata containing the decorators defined on the model.
 This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 __pydantic_post_init__: The name of the post-init method for the model, if defined.
 __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

 __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

 __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 is set to `'allow'`.
 __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 __pydantic_private__: Values of private attributes set on the model instance.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ExploitStep`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

### SecurityValidator

<Tabs>
<TabItem label="Overview">

```python
class SecurityValidator:
    """
    Comprehensive security validator for exploit engine operations
    """
```

Comprehensive security validator for exploit engine operations.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self)
```

Initialize a new instance of `SecurityValidator`.

</TabItem>
</Tabs>

#### Methods

##### sanitize_template_variables

:::note[Method]
Instance method
:::

```python
def sanitize_template_variables(self, variables: dict[str, typing.Any]) -> dict[str, typing.Any]
```

Sanitize template variables for safe substitution.

**Args:**
- **variables**: Dictionary of template variables

**Returns:**
 Sanitized variables dictionary

##### validate_jsonpath_expression

:::note[Method]
Instance method
:::

```python
def validate_jsonpath_expression(self, expression: str) -> tuple[bool, str]
```

Validate JSONPath expression for safe evaluation.

**Args:**
- **expression**: JSONPath expression to validate

**Returns:**
 Tuple of (is_valid, reason)

##### validate_python_expression

:::note[Method]
Instance method
:::

```python
def validate_python_expression(self, expression: str) -> tuple[bool, str]
```

Validate Python expression for safe evaluation.

**Args:**
- **expression**: Python expression to validate

**Returns:**
 Tuple of (is_valid, reason)

##### validate_session_state_update

:::note[Method]
Instance method
:::

```python
def validate_session_state_update(self, current_state: dict[str, typing.Any], update_data: dict[str, typing.Any]) -> logicpwn.core.exploit_engine.security_validator.SecurityValidationResult
```

Validate and sanitize session state updates to prevent injection attacks.

**Args:**
- **current_state**: Current session state

- **update_data**: Data to be merged into session state

**Returns:**
 SecurityValidationResult with validation status and sanitized data

##### validate_template_variable

:::note[Method]
Instance method
:::

```python
def validate_template_variable(self, var_name: str, var_value: Any) -> tuple[bool, str]
```

Validate template variable name and value for safe substitution.

**Args:**
- **var_name**: Variable name to validate

- **var_value**: Variable value to validate

**Returns:**
 Tuple of (is_valid, reason)


---

### ValidationResult

<Tabs>
<TabItem label="Overview">

```python
class ValidationResult (BaseModel):
    """
    !!! abstract "Usage Documentation"
    [Models](
    """
```

!!! abstract "Usage Documentation"

A base class for creating Pydantic models.

Attributes:
 __class_vars__: The names of the class variables defined on the model.
 __private_attributes__: Metadata about the private attributes of the model.
 __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.

 __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
 __pydantic_core_schema__: The core schema of the model.
 __pydantic_custom_init__: Whether the model has a custom `__init__` function.
 __pydantic_decorators__: Metadata containing the decorators defined on the model.
 This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
 __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
 __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
 __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
 __pydantic_post_init__: The name of the post-init method for the model, if defined.
 __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].
 __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.
 __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.

 __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.
 __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.

 __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]
 is set to `'allow'`.
 __pydantic_fields_set__: The names of fields explicitly set during instantiation.
 __pydantic_private__: Values of private attributes set on the model instance.

</TabItem>
<TabItem label="Constructor">

```python
def __init__(self, /, **data: 'Any') -> 'None'
```

Initialize a new instance of `ValidationResult`.

</TabItem>
</Tabs>

#### Properties

<details>
<summary><code>model_extra</code></summary>

Get extra fields set during validation.

**Returns:**
 A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.

</details>

<details>
<summary><code>model_fields_set</code></summary>

Returns the set of fields that have been explicitly set on this model instance.

**Returns:**
 A set of strings representing the fields that have been set,
 i.e. that were not filled from defaults.

</details>

#### Methods

##### construct

:::note[Method]
Instance method
:::

```python
def construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Documentation for `construct` is not available.

##### copy

:::note[Method]
Instance method
:::

```python
def copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

Returns a copy of the model.

!!! warning "Deprecated"
 This method is now deprecated; use `model_copy` instead.

If you need `include` or `exclude`, use:

```python {test="skip" lint="skip"}
data = self.model_dump(include=include, exclude=exclude, round_trip=True)
data = {**data, **(update or {})}
copied = self.model_validate(data)
```

**Args:**
- **include**: Optional set or mapping specifying which fields to include in the copied model.

- **exclude**: Optional set or mapping specifying which fields to exclude in the copied model.

- **update**: Optional dictionary of field-value pairs to override field values in the copied model.

- **deep**: If True, the values of fields that are Pydantic models will be deep-copied.

**Returns:**
 A copy of the model with included, excluded and updated fields as specified.

##### dict

:::note[Method]
Instance method
:::

```python
def dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
```

Documentation for `dict` is not available.

##### from_orm

:::note[Method]
Instance method
:::

```python
def from_orm(obj: 'Any') -> 'Self'
```

Documentation for `from_orm` is not available.

##### json

:::note[Method]
Instance method
:::

```python
def json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `json` is not available.

##### model_construct

:::note[Method]
Instance method
:::

```python
def model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
```

Creates a new instance of the `Model` class with validated data.

Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
Default values are respected, but no other validation is performed.

!!! note
 `model_construct()` generally respects the `model_config.extra` setting on the provided model.
 That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
 and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
 Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
 an error if extra values are passed, but they will be ignored.

**Args:**
- **_fields_set**: A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute. Otherwise, the field names from the `values` argument will be used.

- **values**: Trusted or pre-validated data dictionary.

**Returns:**
 A new instance of the `Model` class with validated data.

##### model_copy

:::note[Method]
Instance method
:::

```python
def model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
```

!!! abstract "Usage Documentation"

Returns a copy of the model.

!!! note
 The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This
 might have unexpected side effects if you store anything in it, on top of the model
 fields (e.g. the value of [cached properties][functools.cached_property]).

**Args:**
- **update**: Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.

- **deep**: Set to `True` to make a deep copy of the model.

**Returns:**
 New model instance.

##### model_dump

:::note[Method]
Instance method
:::

```python
def model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
```

!!! abstract "Usage Documentation"

Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

**Args:**
- **mode**: The mode in which `to_python` should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.

- **include**: A set of fields to include in the output.

- **exclude**: A set of fields to exclude from the output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to use the field's alias in the dictionary key if defined.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A dictionary representation of the model.

##### model_dump_json

:::note[Method]
Instance method
:::

```python
def model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
```

!!! abstract "Usage Documentation"

Generates a JSON representation of the model using Pydantic's `to_json` method.

**Args:**
- **indent**: Indentation to use in the JSON output. If None is passed, the output will be compact.

- **include**: Field(s) to include in the JSON output.

- **exclude**: Field(s) to exclude from the JSON output.

- **context**: Additional context to pass to the serializer.

- **by_alias**: Whether to serialize using field aliases.

- **exclude_unset**: Whether to exclude fields that have not been explicitly set.

- **exclude_defaults**: Whether to exclude fields that are set to their default value.

- **exclude_none**: Whether to exclude fields that have a value of `None`.

- **round_trip**: If True, dumped values should be valid as input for non-idempotent types such as Json[T].

- **warnings**: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors, "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].

- **fallback**: A function to call when an unknown value is encountered. If not provided, a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.

- **serialize_as_any**: Whether to serialize fields with duck-typing serialization behavior.

**Returns:**
 A JSON string representation of the model.

##### model_json_schema

:::note[Method]
Instance method
:::

```python
def model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'
```

Generates a JSON schema for a model class.

**Args:**
- **by_alias**: Whether to use attribute aliases or not.

- **ref_template**: The reference template.

- **schema_generator**: To override the logic used to generate the JSON schema, as a subclass of `GenerateJsonSchema` with your desired modifications

- **mode**: The mode in which to generate the schema.

**Returns:**
 The JSON schema for the given model class.

##### model_parametrized_name

:::note[Method]
Instance method
:::

```python
def model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
```

Compute the class name for parametrizations of generic classes.

This method can be overridden to achieve a custom naming scheme for generic BaseModels.

**Args:**
- **params**: Tuple of types of the class. Given a generic class `Model` with 2 type variables and a concrete model `Model[str, int]`, the value `(str, int)` would be passed to `params`.

**Returns:**
 String representing the new class where `params` are passed to `cls` as type variables.

**Raises:**

- **TypeError**: Raised when trying to generate concrete names for non-generic models.

##### model_post_init

:::note[Method]
Instance method
:::

```python
def model_post_init(self, context: 'Any', /) -> 'None'
```

Override this method to perform additional initialization after `__init__` and `model_construct`.
This is useful if you want to do some validation that requires the entire model to be initialized.

##### model_rebuild

:::note[Method]
Instance method
:::

```python
def model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
```

Try to rebuild the pydantic-core schema for the model.

This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
the initial attempt to build the schema, and automatic rebuilding fails.

**Args:**
- **force**: Whether to force the rebuilding of the model schema, defaults to `False`.

- **raise_errors**: Whether to raise errors, defaults to `True`.

- **_parent_namespace_depth**: The depth level of the parent namespace, defaults to 2.

- **_types_namespace**: The types namespace, defaults to `None`.

**Returns:**
 Returns `None` if the schema is already "complete" and rebuilding was not required.
 If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.

##### model_validate

:::note[Method]
Instance method
:::

```python
def model_validate(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate a pydantic model instance.

**Args:**
- **obj**: The object to validate.

- **strict**: Whether to enforce types strictly.

- **from_attributes**: Whether to extract data from object attributes.

- **context**: Additional context to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Raises:**

- **ValidationError**: If the object could not be validated.

**Returns:**
 The validated model instance.

##### model_validate_json

:::note[Method]
Instance method
:::

```python
def model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

!!! abstract "Usage Documentation"

Validate the given JSON data against the Pydantic model.

**Args:**
- **json_data**: The JSON data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

**Raises:**

- **ValidationError**: If `json_data` is not a JSON string or the object could not be validated.

##### model_validate_strings

:::note[Method]
Instance method
:::

```python
def model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
```

Validate the given object with string data against the Pydantic model.

**Args:**
- **obj**: The object containing string data to validate.

- **strict**: Whether to enforce types strictly.

- **context**: Extra variables to pass to the validator.

- **by_alias**: Whether to use the field's alias when validating against the provided input data.

- **by_name**: Whether to use the field's name when validating against the provided input data.

**Returns:**
 The validated Pydantic model.

##### parse_file

:::note[Method]
Instance method
:::

```python
def parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_file` is not available.

##### parse_obj

:::note[Method]
Instance method
:::

```python
def parse_obj(obj: 'Any') -> 'Self'
```

Documentation for `parse_obj` is not available.

##### parse_raw

:::note[Method]
Instance method
:::

```python
def parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
```

Documentation for `parse_raw` is not available.

##### schema

:::note[Method]
Instance method
:::

```python
def schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
```

Documentation for `schema` is not available.

##### schema_json

:::note[Method]
Instance method
:::

```python
def schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
```

Documentation for `schema_json` is not available.

##### update_forward_refs

:::note[Method]
Instance method
:::

```python
def update_forward_refs(**localns: 'Any') -> 'None'
```

Documentation for `update_forward_refs` is not available.

##### validate

:::note[Method]
Instance method
:::

```python
def validate(value: 'Any') -> 'Self'
```

Documentation for `validate` is not available.


---

## Functions

:::note[Available Functions]
This module provides 4 function(s) for direct use.
:::

### async_run_exploit_chain

:::note[Async Function]
Asynchronous function
:::

```python
async def async_run_exploit_chain(session: requests.sessions.Session, chain: logicpwn.core.exploit_engine.models.ExploitChain, config: Optional[dict[str, Any]] = None) -> Any
```

Async version of run_exploit_chain. Supports parallel execution of steps if chain.parallel_execution is True.
Includes circuit breaker protection for enhanced reliability.

**Usage Example:**
```python
result = await async_run_exploit_chain(...)
```

### inject_payload

:::note[Function]
Module function
:::

```python
def inject_payload(request_config: logicpwn.models.request_config.RequestConfig, injection_points: list[logicpwn.core.exploit_engine.models.PayloadInjectionPoint], session_state: dict[str, typing.Any]) -> logicpwn.models.request_config.RequestConfig
```

Inject payloads into request at specified locations.
Supports injection into:
- URL parameters and path
- HTTP headers
- JSON body fields (using dot notation)
- Form data
- Raw body content

Enhanced with proper error handling and validation.

### load_exploit_chain_from_file

:::note[Function]
Module function
:::

```python
def load_exploit_chain_from_file(file_path: str) -> logicpwn.core.exploit_engine.models.ExploitChain
```

Load an exploit chain from a YAML or JSON file.

### validate_step_success

:::note[Function]
Module function
:::

```python
def validate_step_success(response: Any, step: logicpwn.core.exploit_engine.models.ExploitStep, session_state: dict[str, typing.Any]) -> logicpwn.core.exploit_engine.models.ValidationResult
```

Validate if exploit step succeeded based on response.
Checks:
- HTTP status codes
- Response headers
- Body content patterns
- JSON field values
- Session state changes


## Related Modules

:::tip[Exploit Engine Modules]
Explore other modules in the Exploit Engine category:

- **[Exploit Engine › Exploit Engine](./exploit-engine/exploit-engine)** - Main exploit engine orchestrator
- **[Exploit Engine › Security Validator](./exploit-engine/security-validator)** - Security validation utilities
- **[Exploit Engine › Validation Engine](./exploit-engine/validation-engine)** - Validation engine for exploits
- **[Exploit Engine › Payload Generator](./exploit-engine/payload-generator)** - Payload generation utilities
- **[Exploit Engine › Models](./exploit-engine/models)** - Exploit engine data models
:::
