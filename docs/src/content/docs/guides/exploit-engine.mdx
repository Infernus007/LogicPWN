---
title: Exploit Engine
description: Guide to exploit engine in LogicPWN
category: Guides
sidebar:
  order: 3
---
import { Card, CardGrid, Steps, TabItem, Tabs } from '@astrojs/starlight/components';

## Overview

The Exploit Engine provides advanced capabilities for chaining exploits, validating security controls, and executing complex attack scenarios. It's designed to simulate real-world attack patterns and validate your application's security posture.

<Card title="Key Capabilities" icon="approve-check">
- Chain multiple exploits into complex attack scenarios
- Validate security controls and access mechanisms
- Execute conditional exploits based on previous results
- Generate comprehensive security reports
- Support for custom exploit templates and payloads
</Card>

## Quick Start

<Steps>
1. **Import Exploit Engine**

   ```python
   from logicpwn.core.exploit_engine import ExploitEngine, ExploitChain
   from logicpwn.core.runner import AsyncRequestRunner
   ```

2. **Create Your First Chain**

   ```python
   async def basic_exploit_chain():
       async with AsyncRequestRunner() as runner:
           engine = ExploitEngine(runner)

           chain = ExploitChain(
               name="Basic IDOR Chain",
               description="Test for IDOR vulnerabilities"
           )

           chain.add_step(
               name="Test User Access",
               method="GET",
               url="https://example.com/api/users/1",
               expected_status=200
           )

           return await engine.execute_chain(chain)
   ```

3. **Execute and Analyze**

   ```python
   # Execute the chain
   results = await engine.execute_chain(chain)

   # Analyze results
   for result in results:
       if result.validation_passed:
           print(f"✅ {result.step_name}: Success")
       else:
           print(f"❌ {result.step_name}: Failed")
   ```
</Steps>

## Basic Exploit Execution

### Simple Exploit Chain

```python
from logicpwn.core.exploit_engine import ExploitEngine, ExploitChain
from logicpwn.core.runner import AsyncRequestRunner

async def basic_exploit_chain():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)
        chain = ExploitChain(
            name="Basic IDOR Chain",
            description="Test for IDOR vulnerabilities"
        )
        chain.add_step(
            name="Test User Access",
            method="GET",
            url="https://example.com/api/users/1",
            expected_status=200
        )
        chain.add_step(
            name="Test Admin Access",
            method="GET",
            url="https://example.com/api/admin/users/1",
            expected_status=403
        )
        results = await engine.execute_chain(chain)
        return results
```

### Exploit Validation

```python
async def exploit_validation():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)
        chain = ExploitChain(
            name="Access Control Validation",
            description="Validate access control mechanisms"
        )
        chain.add_step(
            name="Unauthenticated Access",
            method="GET",
            url="https://example.com/api/protected",
            expected_status=401,
            validate_response=True

        # Create validation chain
        chain = ExploitChain(
            name="Access Control Validation",
            description="Validate access control mechanisms"
        )

        # Add validation steps
        chain.add_step(
            name="Unauthenticated Access",
            method="GET",
            url="https://example.com/api/protected",
            expected_status=401,
            validate_response=True
        )

        chain.add_step(
            name="Authenticated Access",
            method="GET",
            url="https://example.com/api/protected",
            auth_required=True,
            expected_status=200
        )

        # Execute with validation
        results = await engine.execute_chain(chain)

        # Check validation results
        for result in results:
            if result.validation_passed:
                print(f"✅ {result.step_name}: Validation passed")
            else:
                print(f"❌ {result.step_name}: Validation failed")

        return results
```

## Advanced Exploit Patterns

<Tabs>
<TabItem label="Multi-Step Attack Chain">
Create complex attack scenarios that simulate real-world attack patterns:

```python
async def multi_step_attack():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        # Create complex attack chain
        chain = ExploitChain(
            name="Privilege Escalation Chain",
            description="Test for privilege escalation vulnerabilities"
        )

        # Step 1: Initial access
        chain.add_step(
            name="Initial Access",
            method="POST",
            url="https://example.com/login",
            data={"username": "user", "password": "password"},
            expected_status=200,
            extract_session=True
        )

        # Step 2: Test user permissions
        chain.add_step(
            name="Test User Permissions",
            method="GET",
            url="https://example.com/api/user/profile",
            expected_status=200
        )

        # Step 3: Attempt privilege escalation
        chain.add_step(
            name="Privilege Escalation",
            method="GET",
            url="https://example.com/api/admin/users",
            expected_status=403,
            validate_response=True
        )

        # Step 4: Test admin endpoints
        chain.add_step(
            name="Admin Endpoint Test",
            method="GET",
            url="https://example.com/api/admin/system",
            expected_status=403
        )

        # Execute chain
        results = await engine.execute_chain(chain)

        return results
```
</TabItem>

<TabItem label="Conditional Exploit Execution">
Execute exploits based on previous results and application characteristics:

```python
async def conditional_exploits():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        chain = ExploitChain(
            name="Conditional Exploit Chain",
            description="Execute exploits based on previous results"
        )

        # Step 1: Check application version
        chain.add_step(
            name="Version Check",
            method="GET",
            url="https://example.com/api/version",
            expected_status=200,
            extract_data=True
        )

        # Step 2: Conditional exploit based on version
        chain.add_step(
            name="Version-Specific Exploit",
            method="GET",
            url="https://example.com/api/exploit",
            condition=lambda prev_result: "v1.0" in prev_result.response_data,
            expected_status=200
        )

        # Execute chain
        results = await engine.execute_chain(chain)

        return results
```
</TabItem>

<TabItem label="Session-Based Exploits">
Chain exploits that require session management and authentication:

```python
async def session_based_exploits():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        chain = ExploitChain(
            name="Session-Based Attack",
            description="Test session management vulnerabilities"
        )

        # Login and extract session
        chain.add_step(
            name="Authentication",
            method="POST",
            url="https://example.com/login",
            data={"username": "user", "password": "password"},
            extract_session=True
        )

        # Use session for protected requests
        chain.add_step(
            name="Protected Resource Access",
            method="GET",
            url="https://example.com/api/protected",
            use_session=True
        )

        return await engine.execute_chain(chain)
```
</TabItem>
</Tabs>

## Exploit Configuration

### Custom Exploit Templates

```python
from logicpwn.core.exploit_engine import ExploitTemplate

# Create custom exploit template
class IDORTemplate(ExploitTemplate):
    def __init__(self, base_url, endpoints):
        self.base_url = base_url
        self.endpoints = endpoints

    def create_chain(self):
        chain = ExploitChain(
            name="IDOR Template",
            description="Template for IDOR testing"
        )

        for endpoint in self.endpoints:
            chain.add_step(
                name=f"Test {endpoint}",
                method="GET",
                url=f"{self.base_url}{endpoint}",
                expected_status=200
            )

        return chain

# Use template
async def use_template():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        # Create template instance
        template = IDORTemplate(
            base_url="https://example.com",
            endpoints=["/api/users/1", "/api/users/2", "/api/orders/1"]
        )

        # Generate chain from template
        chain = template.create_chain()

        # Execute chain
        results = await engine.execute_chain(chain)

        return results
```

### Exploit Payloads

```python
async def payload_testing():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        # Define payloads
        payloads = [
            {"id": "1"},
            {"id": "2"},
            {"id": "admin"},
            {"id": "test"},
            {"id": "999999"}
        ]

        # Create chain with payloads
        chain = ExploitChain(
            name="Payload Testing",
            description="Test various payloads"
        )

        for payload in payloads:
            chain.add_step(
                name=f"Test payload: {payload['id']}",
                method="GET",
                url=f"https://example.com/api/users/{payload['id']}",
                expected_status=200
            )

        # Execute chain
        results = await engine.execute_chain(chain)

        return results
```

## Security Validation

<Steps>
1. **Input Validation Testing**

   Test various input validation mechanisms to identify injection vulnerabilities:

   ```python
   async def input_validation_test():
       async with AsyncRequestRunner() as runner:
           engine = ExploitEngine(runner)

           # Test various input validation scenarios
           chain = ExploitChain(
               name="Input Validation Test",
               description="Test input validation mechanisms"
           )

           # SQL Injection test
           chain.add_step(
               name="SQL Injection Test",
               method="GET",
               url="https://example.com/api/users/1' OR '1'='1",
               expected_status=400,
               validate_response=True
           )

           # XSS test
           chain.add_step(
               name="XSS Test",
               method="GET",
               url="https://example.com/api/search?q=<script>alert('xss')</script>",
               expected_status=400
           )

           # Path traversal test
           chain.add_step(
               name="Path Traversal Test",
               method="GET",
               url="https://example.com/api/files/../../../etc/passwd",
               expected_status=400
           )

           # Execute chain
           results = await engine.execute_chain(chain)

           return results
   ```

   This approach tests multiple injection vectors systematically.

2. **Authentication Bypass Testing**

   Validate authentication mechanisms and test for bypass vulnerabilities:

   ```python
   async def auth_bypass_test():
       async with AsyncRequestRunner() as runner:
           engine = ExploitEngine(runner)

           chain = ExploitChain(
               name="Authentication Bypass Test",
               description="Test for authentication bypass vulnerabilities"
           )

           # Test without authentication
           chain.add_step(
               name="No Auth Test",
               method="GET",
               url="https://example.com/api/protected",
               expected_status=401
           )

           # Test with invalid token
           chain.add_step(
               name="Invalid Token Test",
               method="GET",
               url="https://example.com/api/protected",
               headers={"Authorization": "Bearer invalid-token"},
               expected_status=401
           )

           # Test with expired token
           chain.add_step(
               name="Expired Token Test",
               method="GET",
               url="https://example.com/api/protected",
               headers={"Authorization": "Bearer expired-token"},
               expected_status=401
           )

           # Execute chain
           results = await engine.execute_chain(chain)

           return results
   ```

   This validates that authentication controls are properly implemented.

3. **Authorization Testing**

   Test authorization mechanisms and privilege escalation:

   ```python
   async def authorization_test():
       async with AsyncRequestRunner() as runner:
           engine = ExploitEngine(runner)

           chain = ExploitChain(
               name="Authorization Test",
               description="Test authorization controls"
           )

           # Test user role access
           chain.add_step(
               name="User Role Test",
               method="GET",
               url="https://example.com/api/user/data",
               expected_status=200
           )

           # Test admin role access (should fail for user)
           chain.add_step(
               name="Admin Role Test",
               method="GET",
               url="https://example.com/api/admin/data",
               expected_status=403
           )

           return await engine.execute_chain(chain)
   ```

   This ensures proper role-based access control.
</Steps>

## Integration with Other Components

### With Access Detection

```python
from logicpwn.core.access import detect_idor_flaws

async def integrated_exploit_test():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        # First, detect IDOR vulnerabilities
        idor_results = await detect_idor_flaws(
            runner=runner,
            base_url="https://example.com",
            auth_config=auth_config,
            test_endpoints=["/api/users/1", "/api/users/2"]
        )

        # Then, create exploit chain based on results
        chain = ExploitChain(
            name="IDOR Exploit Chain",
            description="Exploit detected IDOR vulnerabilities"
        )

        for result in idor_results:
            if result.is_vulnerable:
                chain.add_step(
                    name=f"Exploit {result.endpoint}",
                    method="GET",
                    url=f"https://example.com{result.endpoint}",
                    expected_status=200
                )

        # Execute exploit chain
        exploit_results = await engine.execute_chain(chain)

        return exploit_results
```

### With Stress Testing

```python
from logicpwn.core.stress import StressTester

async def stress_exploit_test():
    async with AsyncRequestRunner() as runner:
        engine = ExploitEngine(runner)

        # Create stress test configuration
        stress_config = {
            "concurrent_users": 50,
            "requests_per_user": 5,
            "test_duration": 30
        }

        # Run stress test
        stress_results = await StressTester(runner).run_stress_test(
            base_url="https://example.com",
            config=stress_config
        )

        # Create exploit chain based on stress test results
        chain = ExploitChain(
            name="Post-Stress Exploit",
            description="Test for vulnerabilities after stress testing"
        )

        # Add exploit steps
        chain.add_step(
            name="Post-Stress Access Test",
            method="GET",
            url="https://example.com/api/protected",
            expected_status=200
        )

        # Execute exploit chain
        exploit_results = await engine.execute_chain(chain)

        return exploit_results
```

## Best Practices

<CardGrid stagger>
	<Card title="Plan Your Chains" icon="list">
		Design exploit chains with clear objectives and expected outcomes.
	</Card>
	<Card title="Validate Responses" icon="check">
		Always validate responses to ensure exploits are working as expected.
	</Card>
	<Card title="Handle Errors" icon="warning">
		Implement proper error handling for robust exploit execution.
	</Card>
	<Card title="Document Results" icon="book">
		Document exploit results for security analysis and reporting.
	</Card>
</CardGrid>

### 1. Chain Design

```python
# Good: Clear chain structure
chain = ExploitChain(
    name="Clear Objective",
    description="Well-defined purpose"
)

# Bad: Unclear chain structure
chain = ExploitChain(
    name="Test",
    description="Testing"
)
```

### 2. Response Validation

```python
# Good: Validate responses
chain.add_step(
    name="Test Step",
    method="GET",
    url="https://example.com/api/test",
    expected_status=200,
    validate_response=True
)

# Bad: No validation
chain.add_step(
    name="Test Step",
    method="GET",
    url="https://example.com/api/test"
)
```

### 3. Error Handling

```python
# Good: Handle errors gracefully
try:
    results = await engine.execute_chain(chain)
except Exception as e:
    print(f"Chain execution failed: {e}")
    return None

# Bad: No error handling
results = await engine.execute_chain(chain)
```

## Troubleshooting

### Common Issues

**Chain Execution Failures**: Check step configuration:
```python
# Verify step configuration
for step in chain.steps:
    print(f"Step: {step.name}")
    print(f"URL: {step.url}")
    print(f"Method: {step.method}")
```

**Validation Failures**: Adjust validation logic:
```python
# Custom validation function
def custom_validator(result):
    return result.status_code == 200 and "success" in result.response_data

# Use in step
chain.add_step(
    name="Custom Validation",
    method="GET",
    url="https://example.com/api/test",
    validator=custom_validator
)
```

**Performance Issues**: Optimize chain execution:
```python
# Use concurrent execution for independent steps
results = await engine.execute_chain_concurrent(chain)
```

## Related Guides

<CardGrid stagger>
<Card title="Access Detection" icon="search" link="/guides/access-detection/">
Learn about IDOR vulnerability detection and access control testing.
</Card>

<Card title="Async Runner" icon="rocket" link="/guides/async-runner/">
Explore high-performance asynchronous request handling for security testing.
</Card>

<Card title="API Reference" icon="book" link="/api-reference/">
Browse the complete API documentation for all LogicPWN components.
</Card>
</CardGrid>

## Next Steps

Now that you understand the Exploit Engine, you can:

1. **Combine with Access Detection** to create comprehensive security test suites
2. **Use Async Runner** for high-performance exploit chain execution
3. **Build custom exploit templates** for your specific use cases
4. **Check out examples** in the `/examples` directory for real-world implementations
