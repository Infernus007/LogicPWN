#!/usr/bin/env python3
"""
Async Exploit Chaining Example for LogicPwn Framework.

This example demonstrates high-performance async request execution
for business logic exploitation and multi-step attack automation.
Shows concurrent request execution, session persistence, and
advanced exploit chaining workflows.

Features Demonstrated:
- Async request execution with aiohttp
- Concurrent exploit chaining
- Session management with authentication
- Batch request processing
- Advanced response analysis
- Error handling and retry logic
- Security vulnerability detection

Usage:
    python async_exploit_chaining.py

Requirements:
    - aiohttp (for async HTTP requests)
    - asyncio (for async/await support)
"""

import asyncio
import json
import time
from typing import List, Dict, Any
from dataclasses import dataclass

from logicpwn.core import (
    AsyncRequestRunner,
    AsyncSessionManager,
    send_request_async,
    send_requests_batch_async,
    async_session_manager,
    log_info,
    log_error,
    log_warning
)
from logicpwn.models import RequestConfig, RequestResult
from logicpwn.exceptions import ValidationError, NetworkError


@dataclass
class ExploitStep:
    """Configuration for a single exploit step."""
    name: str
    url: str
    method: str = "GET"
    headers: Dict[str, str] = None
    data: Dict[str, Any] = None
    json_data: Dict[str, Any] = None
    expected_status: int = 200
    required_for_next: bool = True
    extract_data: List[str] = None
    
    def __post_init__(self):
        if self.headers is None:
            self.headers = {}
        if self.extract_data is None:
            self.extract_data = []


class AsyncExploitChain:
    """High-performance async exploit chaining engine."""
    
    def __init__(self, 
                 base_url: str,
                 auth_config: Dict[str, Any] = None,
                 max_concurrent: int = 10,
                 timeout: int = 30):
        """
        Initialize async exploit chain.
        
        Args:
            base_url: Base URL for all requests
            auth_config: Authentication configuration
            max_concurrent: Maximum concurrent requests
            timeout: Request timeout in seconds
        """
        self.base_url = base_url.rstrip('/')
        self.auth_config = auth_config
        self.max_concurrent = max_concurrent
        self.timeout = timeout
        self.session_data = {}
        self.extracted_data = {}
    
    async def execute_chain(self, exploit_steps: List[ExploitStep]) -> List[RequestResult]:
        """
        Execute a chain of exploits with session persistence.
        
        Args:
            exploit_steps: List of exploit steps to execute
            
        Returns:
            List of RequestResult objects from the exploit chain
        """
        results = []
        
        async with AsyncSessionManager(
            auth_config=self.auth_config,
            max_concurrent=self.max_concurrent,
            timeout=self.timeout
        ) as session:
            
            for step in exploit_steps:
                try:
                    log_info(f"Executing exploit step: {step.name}", {
                        'url': step.url,
                        'method': step.method
                    })
                    
                    # Prepare request data
                    request_data = {}
                    if step.data:
                        request_data['data'] = step.data
                    elif step.json_data:
                        request_data['json_data'] = step.json_data
                    
                    # Execute request
                    if step.method.upper() == 'GET':
                        result = await session.get(step.url, headers=step.headers)
                    elif step.method.upper() == 'POST':
                        result = await session.post(step.url, headers=step.headers, **request_data)
                    elif step.method.upper() == 'PUT':
                        result = await session.put(step.url, headers=step.headers, **request_data)
                    elif step.method.upper() == 'DELETE':
                        result = await session.delete(step.url, headers=step.headers)
                    else:
                        raise ValidationError(f"Unsupported HTTP method: {step.method}")
                    
                    # Validate response
                    if result.status_code != step.expected_status:
                        log_warning(f"Unexpected status code for {step.name}", {
                            'expected': step.expected_status,
                            'actual': result.status_code,
                            'url': step.url
                        })
                        
                        if step.required_for_next:
                            log_error(NetworkError(f"Required step failed: {step.name}"), {
                                'status_code': result.status_code,
                                'url': step.url
                            })
                            break
                    
                    # Extract data if specified
                    if step.extract_data and result.body:
                        self._extract_step_data(step, result)
                    
                    # Check for security vulnerabilities
                    if result.has_vulnerabilities:
                        log_warning(f"Security vulnerabilities detected in {step.name}", {
                            'url': step.url,
                            'vulnerabilities': result.security_analysis
                        })
                    
                    results.append(result)
                    
                except Exception as e:
                    log_error(e, {
                        'step': step.name,
                        'url': step.url,
                        'method': step.method
                    })
                    
                    if step.required_for_next:
                        break
                    else:
                        # Create error result for non-required steps
                        error_result = RequestResult.from_exception(
                            url=step.url,
                            method=step.method,
                            exception=e,
                            duration=0.0
                        )
                        results.append(error_result)
        
        return results
    
    def _extract_step_data(self, step: ExploitStep, result: RequestResult):
        """Extract specified data from response."""
        if not isinstance(result.body, dict):
            return
        
        for field in step.extract_data:
            if field in result.body:
                self.extracted_data[f"{step.name}_{field}"] = result.body[field]
                log_info(f"Extracted data from {step.name}", {
                    'field': field,
                    'value': result.body[field]
                })


async def demonstrate_async_exploit_chaining():
    """Demonstrate async exploit chaining capabilities."""
    
    # Example 1: Simple async request
    print("=== Example 1: Simple Async Request ===")
    try:
        result = await send_request_async(
            url="https://httpbin.org/get",
            method="GET",
            headers={"User-Agent": "LogicPwn-Async/1.0"}
        )
        print(f"Status: {result.status_code}")
        print(f"Response size: {len(str(result.body))} bytes")
        print(f"Has vulnerabilities: {result.has_vulnerabilities}")
        print()
    except Exception as e:
        print(f"Error: {e}")
        print()
    
    # Example 2: Batch async requests
    print("=== Example 2: Batch Async Requests ===")
    request_configs = [
        {"url": "https://httpbin.org/get", "method": "GET"},
        {"url": "https://httpbin.org/post", "method": "POST", "json_data": {"test": "data"}},
        {"url": "https://httpbin.org/put", "method": "PUT", "json_data": {"update": "value"}},
        {"url": "https://httpbin.org/delete", "method": "DELETE"}
    ]
    
    try:
        results = await send_requests_batch_async(request_configs, max_concurrent=4)
        for i, result in enumerate(results):
            print(f"Request {i+1}: {result.status_code} - {result.url}")
        print()
    except Exception as e:
        print(f"Error: {e}")
        print()
    
    # Example 3: Async exploit chain with session management
    print("=== Example 3: Async Exploit Chain ===")
    
    # Simulate authentication config
    auth_config = {
        "url": "https://httpbin.org/post",
        "method": "POST",
        "credentials": {
            "username": "admin",
            "password": "secret123"
        },
        "headers": {
            "Content-Type": "application/x-www-form-urlencoded"
        }
    }
    
    # Define exploit chain steps
    exploit_steps = [
        ExploitStep(
            name="authentication",
            url="https://httpbin.org/post",
            method="POST",
            data={"username": "admin", "password": "secret123"},
            expected_status=200,
            required_for_next=True
        ),
        ExploitStep(
            name="user_profile",
            url="https://httpbin.org/get",
            method="GET",
            expected_status=200,
            required_for_next=False,
            extract_data=["url", "headers"]
        ),
        ExploitStep(
            name="admin_panel",
            url="https://httpbin.org/status/403",
            method="GET",
            expected_status=403,
            required_for_next=False
        ),
        ExploitStep(
            name="data_exploit",
            url="https://httpbin.org/post",
            method="POST",
            json_data={"action": "exploit", "target": "user_data"},
            expected_status=200,
            required_for_next=True
        )
    ]
    
    try:
        chain = AsyncExploitChain(
            base_url="https://httpbin.org",
            auth_config=auth_config,
            max_concurrent=5,
            timeout=30
        )
        
        results = await chain.execute_chain(exploit_steps)
        
        print(f"Executed {len(results)} exploit steps")
        for i, result in enumerate(results):
            print(f"Step {i+1}: {result.status_code} - {result.url}")
            if result.has_vulnerabilities:
                print(f"  Security issues detected!")
        
        print(f"Extracted data: {chain.extracted_data}")
        print()
        
    except Exception as e:
        print(f"Error: {e}")
        print()
    
    # Example 4: High-performance concurrent testing
    print("=== Example 4: High-Performance Concurrent Testing ===")
    
    # Generate many test requests
    test_configs = []
    for i in range(20):
        test_configs.append({
            "url": f"https://httpbin.org/get?test={i}",
            "method": "GET",
            "headers": {"X-Test-ID": str(i)}
        })
    
    try:
        start_time = time.time()
        results = await send_requests_batch_async(test_configs, max_concurrent=10)
        end_time = time.time()
        
        successful = sum(1 for r in results if r.status_code == 200)
        print(f"Executed {len(results)} requests in {end_time - start_time:.2f} seconds")
        print(f"Successful: {successful}/{len(results)}")
        print(f"Average time per request: {(end_time - start_time) / len(results):.3f}s")
        print()
        
    except Exception as e:
        print(f"Error: {e}")
        print()


async def demonstrate_advanced_async_features():
    """Demonstrate advanced async features."""
    
    print("=== Advanced Async Features ===")
    
    # Example: Custom async request runner with rate limiting
    async with AsyncRequestRunner(
        max_concurrent=5,
        rate_limit=10.0,  # 10 requests per second
        timeout=15,
        verify_ssl=True
    ) as runner:
        
        # Execute multiple requests with custom configuration
        custom_configs = [
            {
                "url": "https://httpbin.org/delay/1",
                "method": "GET",
                "timeout": 5
            },
            {
                "url": "https://httpbin.org/delay/2", 
                "method": "GET",
                "timeout": 10
            },
            {
                "url": "https://httpbin.org/status/500",
                "method": "GET"
            }
        ]
        
        try:
            results = await runner.send_requests_batch(custom_configs)
            
            for i, result in enumerate(results):
                print(f"Custom request {i+1}: {result.status_code}")
                if result.error_message:
                    print(f"  Error: {result.error_message}")
                    
        except Exception as e:
            print(f"Error: {e}")
    
    print()


def main():
    """Main function to run async exploit chaining examples."""
    print("🚀 LogicPwn Async Exploit Chaining Demo")
    print("=" * 50)
    print()
    
    # Run async examples
    asyncio.run(demonstrate_async_exploit_chaining())
    asyncio.run(demonstrate_advanced_async_features())
    
    print("✅ Async exploit chaining demonstration completed!")
    print()
    print("Key Features Demonstrated:")
    print("- High-performance async HTTP requests")
    print("- Concurrent request execution")
    print("- Session management with authentication")
    print("- Exploit chaining with persistence")
    print("- Batch request processing")
    print("- Advanced error handling")
    print("- Security vulnerability detection")
    print("- Rate limiting and connection pooling")


if __name__ == "__main__":
    main() 