"""
Validation engine for LogicPwn Exploit Engine.
- Validates response content, status, headers, and session state
- Extensible and interoperable with core models
"""
from typing import Any, Dict
from logicpwn.core.utils.utils import check_indicators
from .models import ExploitStep, ValidationResult

try:
    from jsonpath_ng import parse as jsonpath_parse
except ImportError:
    jsonpath_parse = None

def eval_python_expr(expr: str, response: Any, session_state: dict) -> bool:
    """
    Safely evaluate Python expressions with enhanced error handling.
    
    Args:
        expr: Python expression to evaluate
        response: HTTP response object
        session_state: Current session state
    
    Returns:
        bool: Result of expression evaluation, False on any error
    """
    try:
        # Basic security check - prevent dangerous operations
        dangerous_keywords = ['import', '__', 'exec', 'eval', 'open', 'file', 'input']
        if any(keyword in expr.lower() for keyword in dangerous_keywords):
            return False
        
        # Provide safe context with limited scope
        safe_context = {
            "response": response,
            "session": session_state,
            "len": len,
            "str": str,
            "int": int,
            "float": float,
            "bool": bool,
            "hasattr": hasattr,
            "getattr": getattr,
            "isinstance": isinstance,
        }
        
        # Evaluate with timeout protection
        result = eval(expr, {"__builtins__": {}}, safe_context)
        return bool(result)
    except (SyntaxError, NameError, TypeError, AttributeError, ValueError) as e:
        # Log specific error types for debugging
        import logging
        logging.debug(f"Python expression evaluation failed: {expr} - {type(e).__name__}: {e}")
        return False
    except Exception as e:
        # Catch any other unexpected errors
        import logging
        logging.warning(f"Unexpected error in Python expression evaluation: {expr} - {e}")
        return False

def eval_jsonpath(expr: str, json_body: dict) -> bool:
    """
    Safely evaluate JSONPath expressions with enhanced error handling.
    
    Args:
        expr: JSONPath expression to evaluate
        json_body: JSON data to search
    
    Returns:
        bool: True if path exists and has values, False otherwise
    """
    if not jsonpath_parse or not json_body:
        return False
    
    try:
        # Validate JSONPath expression syntax
        if not expr or not expr.strip():
            return False
        
        # Basic security check for JSONPath injection
        if any(dangerous in expr for dangerous in ['__', 'eval', 'exec']):
            return False
        
        jsonpath_expr = jsonpath_parse(expr)
        matches = [match.value for match in jsonpath_expr.find(json_body)]
        
        # Return True if matches exist and are not None/empty
        return bool(matches) and any(match is not None for match in matches)
        
    except Exception as e:
        # Log parsing errors for debugging
        import logging
        logging.debug(f"JSONPath evaluation failed: {expr} - {e}")
        return False

def validate_step_success(
    response: Any,
    step: ExploitStep,
    session_state: Dict[str, Any]
) -> ValidationResult:
    """
    Validate if exploit step succeeded based on response.
    Checks:
    - HTTP status codes
    - Response headers
    - Body content patterns
    - JSON field values
    - Session state changes
    """
    reasons = []
    matched, failed = [], []
    body = getattr(response, 'text', None)
    if hasattr(response, 'json'):
        try:
            json_body = response.json()
        except Exception:
            json_body = None
    else:
        json_body = None
    # Success indicators
    is_valid, matched = check_indicators(body or '', step.success_indicators, "success")
    # Failure indicators
    is_fail, failed = check_indicators(body or '', step.failure_indicators, "failure")
    # Status code check
    status_code = getattr(response, 'status_code', None)
    # Advanced validation
    for ind in step.success_indicators:
        if ind.startswith("status_code =="):
            try:
                code = int(ind.split("==")[1].strip())
                if status_code == code:
                    is_valid = True
                    matched.append(ind)
            except Exception:
                pass
        elif ind.startswith("status_code !="):
            try:
                code = int(ind.split("!=")[1].strip())
                if status_code != code:
                    is_valid = True
                    matched.append(ind)
            except Exception:
                pass
        elif ind.startswith("py:"):
            expr = ind[3:]
            if eval_python_expr(expr, response, session_state):
                is_valid = True
                matched.append(ind)
        elif ind.startswith("jsonpath:") and json_body:
            expr = ind[9:]
            if eval_jsonpath(expr, json_body):
                is_valid = True
                matched.append(ind)
        elif ind.startswith("session:"):
            expr = ind[8:]
            try:
                if eval(expr, {"session": session_state}):
                    is_valid = True
                    matched.append(ind)
            except Exception:
                pass
        elif ind.endswith("in response.json") and json_body:
            field = ind.split("in response.json")[0].strip()
            if field in json_body:
                is_valid = True
                matched.append(ind)
    # Failure indicators override
    if is_fail:
        is_valid = False
        reasons.extend([f"Failure indicator matched: {f}" for f in failed])
    if not is_valid:
        reasons.append("No success indicators matched.")
    return ValidationResult(
        is_valid=is_valid,
        reasons=reasons,
        matched_indicators=matched,
        failed_indicators=failed,
        extracted_data={}
    ) 